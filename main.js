/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SupernoteCompanionPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  // Device Connection
  deviceIp: "",
  // Must be set by user
  devicePort: 8089,
  // Default Supernote Browse & Access port
  // Sync Configuration
  notesFolder: "/Supernote",
  pdfFolder: "/Supernote/PDFs",
  importMode: "pdf-only",
  // Default to simple PDF-only import
  filenameTemplate: "{name}",
  // Simple default - just use the note name
  preserveFolderStructure: true,
  // Preserve Supernote folder structure by default
  trashedNoteIds: [],
  lastSync: 0,
  // PDF Converter
  converterMode: "cli",
  // Default to CLI (more reliable)
  converterPath: "/home/dpshade/Developer/supernote_obsidian/supernote_pdf/target/release/supernote_pdf",
  // Update Behavior
  updateModifiedFiles: "ask",
  updateMode: "all",
  specificFrontmatterFields: [],
  tagsMergeStrategy: "merge",
  preserveCustomFields: true,
  // Export Options
  attachPdf: true,
  includeThumbnail: false,
  // Advanced
  connectionTimeout: 1e4
};

// src/api/client.ts
var import_obsidian = require("obsidian");
var _SupernoteAPIClient = class {
  constructor(deviceIp, port = 8089, timeout = 1e4) {
    this.deviceIp = deviceIp;
    this.port = port;
    this.timeout = timeout;
  }
  /**
   * Get the base URL for the Supernote device
   */
  get baseURL() {
    return `http://${this.deviceIp}:${this.port}`;
  }
  /**
   * Update the device connection settings
   */
  updateConnection(deviceIp, port = 8089) {
    this.deviceIp = deviceIp;
    this.port = port;
  }
  /**
   * Check if the Supernote device is reachable
   * Uses a GET request to the root path and looks for the embedded JSON
   */
  async checkConnection() {
    try {
      const params = {
        url: `${this.baseURL}/`,
        method: "GET",
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(params);
      const hasJson = Boolean(response.text && _SupernoteAPIClient.RE_JSON.test(response.text));
      return {
        connected: response.status === 200 && hasJson,
        serverUrl: this.baseURL,
        lastChecked: Date.now()
      };
    } catch (error) {
      return {
        connected: false,
        serverUrl: this.baseURL,
        lastChecked: Date.now(),
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Validate the connection is working
   */
  async validateConnection() {
    const status = await this.checkConnection();
    return status.connected;
  }
  /**
   * Fetch list of all .note files from the Supernote device
   * Recursively scans the Note directory
   */
  async fetchNoteFiles() {
    try {
      const allNotes = [];
      await this.scanDirectory("/Note", allNotes);
      return { data: allNotes };
    } catch (error) {
      console.error("Failed to fetch note files:", error);
      throw new Error(`Failed to fetch notes: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Recursively scan a directory for .note files
   */
  async scanDirectory(path3, results) {
    const response = await this.listDirectory(path3);
    for (const file of response.fileList) {
      if (file.isDirectory) {
        await this.scanDirectory(file.uri, results);
      } else if (file.extension === "note") {
        results.push(this.convertToSupernoteFile(file));
      }
    }
  }
  /**
   * List contents of a directory on the Supernote device
   */
  async listDirectory(path3) {
    const params = {
      url: `${this.baseURL}${path3}`,
      method: "GET",
      throw: false
    };
    const response = await (0, import_obsidian.requestUrl)(params);
    if (response.status >= 400) {
      throw new Error(`HTTP ${response.status}: Failed to list directory ${path3}`);
    }
    const match = response.text.match(_SupernoteAPIClient.RE_JSON);
    if (!match) {
      throw new Error(`No JSON data found in response for ${path3}`);
    }
    try {
      return JSON.parse(match[1]);
    } catch (e) {
      throw new Error(`Failed to parse JSON from device response: ${e}`);
    }
  }
  /**
   * Convert device file format to our internal SupernoteFile format
   */
  convertToSupernoteFile(file) {
    var _a;
    const dateStr = file.date;
    const parsedDate = new Date(dateStr.replace(" ", "T") + ":00");
    const decodedUri = decodeURIComponent(file.uri).replace(/\+/g, " ");
    const rawName = ((_a = decodedUri.split("/").pop()) == null ? void 0 : _a.replace(".note", "")) || "Untitled";
    const name = rawName.replace(/\+/g, " ").replace(/\s+/g, " ").trim();
    const id = this.generateFileId(file.uri);
    return {
      id,
      name,
      path: decodedUri,
      size: file.size,
      modifiedAt: parsedDate.toISOString(),
      createdAt: parsedDate.toISOString(),
      // Device doesn't provide creation date separately
      pageCount: void 0
      // Not available from directory listing
    };
  }
  /**
   * Generate a stable ID from the file path
   * Uses a simple hash of the URI
   */
  generateFileId(uri) {
    let hash = 0;
    for (let i = 0; i < uri.length; i++) {
      const char = uri.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return `sn-${Math.abs(hash).toString(16)}`;
  }
  /**
   * Fetch details for a specific note file
   * Note: The device doesn't provide detailed metadata, so this returns basic info
   */
  async fetchNoteDetail(id) {
    const { data: notes } = await this.fetchNoteFiles();
    const note = notes.find((n) => n.id === id);
    if (!note) {
      throw new Error(`Note with id ${id} not found`);
    }
    return { ...note };
  }
  /**
   * Download a .note file from the Supernote device
   * @param filePath The path to the file on the device (e.g., "/Note/MyNote.note")
   * @returns The raw file data as ArrayBuffer
   */
  async downloadNoteFile(filePath) {
    try {
      const encodedPath = filePath.split("/").map((segment) => {
        let encoded = encodeURIComponent(segment);
        encoded = encoded.replace(/%20/g, "+");
        encoded = encoded.replace(/%2B/g, "+");
        return encoded;
      }).join("/");
      const fullUrl = `${this.baseURL}${encodedPath}`;
      console.log(`[client] Downloading: ${fullUrl}`);
      const params = {
        url: fullUrl,
        method: "GET",
        throw: false
      };
      const response = await (0, import_obsidian.requestUrl)(params);
      console.log(`[client] Response for ${filePath}: status=${response.status}, size=${response.arrayBuffer.byteLength}, content-type=${response.headers["content-type"] || "unknown"}`);
      if (response.status >= 400) {
        throw new Error(`HTTP ${response.status}: Failed to download ${filePath}`);
      }
      const contentType = response.headers["content-type"] || "";
      if (contentType.includes("text/html")) {
        console.warn(`[client] Received HTML instead of binary for ${filePath} - device may have returned an error page`);
      }
      return response.arrayBuffer;
    } catch (error) {
      console.error(`[client] Failed to download file ${filePath}:`, error);
      throw new Error(`Failed to download file: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Download a file by path (alias for downloadNoteFile for API compatibility)
   */
  async downloadFile(path3) {
    return this.downloadNoteFile(path3);
  }
  /**
   * Get a thumbnail image for a note
   * Note: The Supernote device doesn't provide thumbnails via its API
   * This would require downloading and parsing the .note file
   */
  async getThumbnail(_noteId) {
    return null;
  }
  /**
   * @deprecated Use downloadNoteFile instead. PDF conversion is done locally.
   * This method is kept for API compatibility but throws an error.
   */
  async requestPdfConversion(_noteId) {
    throw new Error(
      "PDF conversion is not available from the Supernote device. Use the local PdfConverter class with supernote_pdf instead."
    );
  }
};
var SupernoteAPIClient = _SupernoteAPIClient;
// Regex to extract JSON from the HTML response
SupernoteAPIClient.RE_JSON = /const json = '({[^']+})'/;
var MockSupernoteAPIClient = class extends SupernoteAPIClient {
  constructor() {
    super("localhost", 8089);
    this.mockNotes = [
      {
        id: "note-001",
        name: "Meeting Notes",
        path: "/Note/Meeting Notes.note",
        size: 1024e3,
        modifiedAt: new Date().toISOString(),
        createdAt: new Date(Date.now() - 864e5).toISOString(),
        pageCount: 5
      },
      {
        id: "note-002",
        name: "Project Ideas",
        path: "/Note/Project Ideas.note",
        size: 2048e3,
        modifiedAt: new Date(Date.now() - 36e5).toISOString(),
        createdAt: new Date(Date.now() - 1728e5).toISOString(),
        pageCount: 12
      },
      {
        id: "note-003",
        name: "Daily Journal",
        path: "/Note/Journal/Daily Journal.note",
        size: 512e3,
        modifiedAt: new Date(Date.now() - 72e5).toISOString(),
        createdAt: new Date(Date.now() - 6048e5).toISOString(),
        pageCount: 3
      }
    ];
  }
  async checkConnection() {
    return {
      connected: true,
      serverUrl: "http://localhost:8089 (mock)",
      lastChecked: Date.now()
    };
  }
  async validateConnection() {
    return true;
  }
  async fetchNoteFiles() {
    await new Promise((resolve) => setTimeout(resolve, 500));
    return { data: this.mockNotes };
  }
  async fetchNoteDetail(id) {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const note = this.mockNotes.find((n) => n.id === id);
    if (!note) {
      throw new Error(`Note ${id} not found`);
    }
    return { ...note };
  }
  async downloadNoteFile(_filePath) {
    await new Promise((resolve) => setTimeout(resolve, 500));
    return new ArrayBuffer(0);
  }
  async downloadFile(path3) {
    return this.downloadNoteFile(path3);
  }
  async getThumbnail(_noteId) {
    return null;
  }
};

// src/ui/settings-tab.ts
var import_obsidian2 = require("obsidian");

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1) {
    base = lbase;
    extra = lext;
    match = 257;
  } else {
    base = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var deflate_1 = deflate;

// src/api/note-parser.ts
var A5X_WIDTH = 1404;
var A5X_HEIGHT = 1872;
var A5X2_WIDTH = 1920;
var A5X2_HEIGHT = 2560;
var METADATA_RE = /<([^:]+?):([^>]*?)>/g;
var VALID_SIGNATURE_PREFIXES = [
  "noteSN_FILE_VER_",
  // Older .note format (with 'note' prefix in signature area)
  "SN_FILE_VER_",
  // Standard .note format (e.g., SN_FILE_VER_20230015)
  "SN_FILE_ASA_"
  // Alternative format
];
var MIN_NOTE_FILE_SIZE = 100;
var BinaryReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.view = new DataView(buffer);
    this.data = new Uint8Array(buffer);
  }
  get length() {
    return this.data.length;
  }
  get position() {
    return this.pos;
  }
  /**
   * Check if reading `size` bytes from `pos` is within bounds
   */
  checkBounds(pos, size = 1) {
    return pos >= 0 && pos + size <= this.data.length;
  }
  seek(pos) {
    if (pos < 0 || pos > this.data.length) {
      throw new Error(`Seek out of bounds: pos=${pos}, fileLength=${this.data.length}`);
    }
    this.pos = pos;
  }
  seekEnd(offset) {
    const newPos = this.data.length + offset;
    if (newPos < 0 || newPos > this.data.length) {
      throw new Error(`SeekEnd out of bounds: offset=${offset}, fileLength=${this.data.length}`);
    }
    this.pos = newPos;
  }
  readU32LE() {
    if (!this.checkBounds(this.pos, 4)) {
      throw new Error(`Read U32 out of bounds: pos=${this.pos}, fileLength=${this.data.length}`);
    }
    const val = this.view.getUint32(this.pos, true);
    this.pos += 4;
    return val;
  }
  readBytes(length) {
    if (length < 0) {
      throw new Error(`Invalid read length: ${length}`);
    }
    if (!this.checkBounds(this.pos, length)) {
      throw new Error(`Read bytes out of bounds: pos=${this.pos}, length=${length}, fileLength=${this.data.length}`);
    }
    const bytes = this.data.slice(this.pos, this.pos + length);
    this.pos += length;
    return bytes;
  }
  readString(length) {
    const bytes = this.readBytes(length);
    return new TextDecoder().decode(bytes);
  }
};
function validateNoteFile(reader) {
  if (reader.length === 0) {
    throw new Error("File is empty (0 bytes) - download may have failed");
  }
  if (reader.length < MIN_NOTE_FILE_SIZE) {
    throw new Error(`File is too small (${reader.length} bytes) - may be corrupted or not a .note file`);
  }
  const signature = getSignature(reader);
  const isValid = VALID_SIGNATURE_PREFIXES.some((prefix) => signature.startsWith(prefix));
  if (!isValid) {
    reader.seek(0);
    const firstBytes = new TextDecoder().decode(reader.readBytes(Math.min(50, reader.length)));
    if (firstBytes.toLowerCase().includes("<!doctype") || firstBytes.toLowerCase().includes("<html")) {
      throw new Error("Downloaded HTML instead of .note file - device may have returned an error page");
    }
    throw new Error(`Invalid .note file signature: "${signature.substring(0, 20)}" - file may not be a Supernote note`);
  }
}
function parseMetadataBlock(reader, address) {
  if (address === 0) {
    return /* @__PURE__ */ new Map();
  }
  if (address < 0 || address > reader.length - 4) {
    console.warn(`Invalid metadata address: ${address} (file length: ${reader.length})`);
    return /* @__PURE__ */ new Map();
  }
  reader.seek(address);
  const blockLen = reader.readU32LE();
  if (blockLen <= 0 || blockLen > reader.length - address - 4) {
    console.warn(`Invalid block length: ${blockLen} at address ${address} (file length: ${reader.length})`);
    return /* @__PURE__ */ new Map();
  }
  const content = reader.readString(blockLen);
  const map = /* @__PURE__ */ new Map();
  let match;
  const re = new RegExp(METADATA_RE.source, "g");
  while ((match = re.exec(content)) !== null) {
    map.set(match[1], match[2]);
  }
  return map;
}
function getSignature(reader) {
  reader.seek(4);
  return reader.readString(20);
}
function detectDeviceDimensions(reader, footerMap) {
  const fileFeature = footerMap.get("FILE_FEATURE");
  if (fileFeature) {
    const headerAddr = parseInt(fileFeature, 10);
    if (!isNaN(headerAddr)) {
      const headerMap = parseMetadataBlock(reader, headerAddr);
      const equipment = headerMap.get("APPLY_EQUIPMENT");
      if (equipment === "N5") {
        return [A5X2_WIDTH, A5X2_HEIGHT];
      }
    }
  }
  return [A5X_WIDTH, A5X_HEIGHT];
}
function parseNotebook(reader) {
  const signature = getSignature(reader);
  reader.seekEnd(-4);
  const footerAddr = reader.readU32LE();
  const footerMap = parseMetadataBlock(reader, footerAddr);
  const [width, height] = detectDeviceDimensions(reader, footerMap);
  const pageEntries = [];
  footerMap.forEach((value, key) => {
    if (key.startsWith("PAGE")) {
      const pageNum = parseInt(key.slice(4), 10);
      const addr = parseInt(value, 10);
      if (!isNaN(pageNum) && !isNaN(addr)) {
        pageEntries.push([pageNum, addr]);
      }
    }
  });
  pageEntries.sort((a, b) => a[0] - b[0]);
  const pages = [];
  for (const [, addr] of pageEntries) {
    const pageMap = parseMetadataBlock(reader, addr);
    const layerSeq = pageMap.get("LAYERSEQ");
    const layerOrder = layerSeq ? layerSeq.split(",") : ["BGLAYER", "MAINLAYER", "LAYER1", "LAYER2", "LAYER3"];
    const layers = [];
    for (const layerKey of layerOrder) {
      const layerAddrStr = pageMap.get(layerKey);
      if (layerAddrStr) {
        const layerAddr = parseInt(layerAddrStr, 10);
        const layerData = parseMetadataBlock(reader, layerAddr);
        layers.push({
          key: layerKey,
          protocol: layerData.get("LAYERPROTOCOL") || "",
          bitmapAddress: parseInt(layerData.get("LAYERBITMAP") || "0", 10)
        });
      }
    }
    pages.push({ addr, layers });
  }
  return { signature, pages, width, height };
}
function decodeRLE(compressedData, width, height) {
  const expectedLen = width * height;
  const decompressed = [];
  let i = 0;
  let holder = null;
  while (i < compressedData.length) {
    if (i + 1 >= compressedData.length)
      break;
    const colorCode = compressedData[i];
    const lengthCode = compressedData[i + 1];
    i += 2;
    let length;
    if (holder !== null) {
      const [prevColorCode, prevLengthCode] = holder;
      holder = null;
      if (colorCode === prevColorCode) {
        length = 1 + lengthCode + ((prevLengthCode & 127) + 1 << 7);
      } else {
        const heldLength = (prevLengthCode & 127) + 1 << 7;
        for (let j = 0; j < heldLength; j++) {
          decompressed.push(prevColorCode);
        }
        length = lengthCode + 1;
      }
    } else if (lengthCode === 255) {
      length = 16384;
    } else if ((lengthCode & 128) !== 0) {
      holder = [colorCode, lengthCode];
      continue;
    } else {
      length = lengthCode + 1;
    }
    for (let j = 0; j < length; j++) {
      decompressed.push(colorCode);
    }
  }
  if (holder !== null) {
    const [colorCode, lengthCode] = holder;
    const remainingLen = expectedLen - decompressed.length;
    const tailLength = Math.min((lengthCode & 127) + 1 << 7, remainingLen);
    for (let j = 0; j < tailLength; j++) {
      decompressed.push(colorCode);
    }
  }
  while (decompressed.length < expectedLen) {
    decompressed.push(98);
  }
  if (decompressed.length > expectedLen) {
    decompressed.length = expectedLen;
  }
  return new Uint8Array(decompressed);
}
function toRGBA(pixelByte) {
  switch (pixelByte) {
    case 97:
      return [0, 0, 0, 255];
    case 101:
      return [255, 255, 255, 255];
    case 98:
      return [0, 0, 0, 0];
    case 99:
    case 157:
    case 158:
      return [157, 157, 157, 255];
    case 100:
    case 201:
    case 202:
      return [201, 201, 201, 255];
    default:
      return [pixelByte, pixelByte, pixelByte, 255];
  }
}
async function decodePNG(pngData, width, height) {
  try {
    const blob = new Blob([pngData], { type: "image/png" });
    const imageBitmap = await createImageBitmap(blob);
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      console.warn("[note-parser] Could not get 2d context for PNG decoding");
      return null;
    }
    ctx.drawImage(imageBitmap, 0, 0, width, height);
    const imageData = ctx.getImageData(0, 0, width, height);
    return new Uint8Array(imageData.data.buffer);
  } catch (err2) {
    console.warn("[note-parser] Failed to decode PNG layer:", err2);
    return null;
  }
}
async function renderPage(reader, page, width, height) {
  const canvas = new Uint8Array(width * height * 4);
  for (let i = 0; i < width * height; i++) {
    canvas[i * 4 + 0] = 255;
    canvas[i * 4 + 1] = 255;
    canvas[i * 4 + 2] = 255;
    canvas[i * 4 + 3] = 255;
  }
  for (const layer of page.layers) {
    if (layer.bitmapAddress === 0)
      continue;
    reader.seek(layer.bitmapAddress);
    const blockLen = reader.readU32LE();
    const compressedData = reader.readBytes(blockLen);
    let layerPixels = null;
    if (layer.protocol === "RATTA_RLE") {
      layerPixels = decodeRLE(compressedData, width, height);
      for (let i = 0; i < width * height; i++) {
        const [r, g, b, a] = toRGBA(layerPixels[i]);
        if (a === 0)
          continue;
        const idx = i * 4;
        if (a === 255) {
          canvas[idx + 0] = r;
          canvas[idx + 1] = g;
          canvas[idx + 2] = b;
          canvas[idx + 3] = 255;
        } else {
          const alpha = a / 255;
          const invAlpha = 1 - alpha;
          canvas[idx + 0] = Math.round(r * alpha + canvas[idx + 0] * invAlpha);
          canvas[idx + 1] = Math.round(g * alpha + canvas[idx + 1] * invAlpha);
          canvas[idx + 2] = Math.round(b * alpha + canvas[idx + 2] * invAlpha);
        }
      }
    } else if (layer.protocol === "PNG") {
      layerPixels = await decodePNG(compressedData, width, height);
      if (layerPixels) {
        for (let i = 0; i < width * height; i++) {
          const idx = i * 4;
          const a = layerPixels[idx + 3];
          if (a === 0)
            continue;
          const r = layerPixels[idx + 0];
          const g = layerPixels[idx + 1];
          const b = layerPixels[idx + 2];
          if (a === 255) {
            canvas[idx + 0] = r;
            canvas[idx + 1] = g;
            canvas[idx + 2] = b;
            canvas[idx + 3] = 255;
          } else {
            const alpha = a / 255;
            const invAlpha = 1 - alpha;
            canvas[idx + 0] = Math.round(r * alpha + canvas[idx + 0] * invAlpha);
            canvas[idx + 1] = Math.round(g * alpha + canvas[idx + 1] * invAlpha);
            canvas[idx + 2] = Math.round(b * alpha + canvas[idx + 2] * invAlpha);
          }
        }
      }
    } else {
      console.warn(`[note-parser] Unknown layer protocol: ${layer.protocol}`);
      continue;
    }
  }
  return canvas;
}
function rgbaToRgb(rgba, width, height) {
  const rgb = new Uint8Array(width * height * 3);
  for (let i = 0; i < width * height; i++) {
    rgb[i * 3 + 0] = rgba[i * 4 + 0];
    rgb[i * 3 + 1] = rgba[i * 4 + 1];
    rgb[i * 3 + 2] = rgba[i * 4 + 2];
  }
  return rgb;
}
function buildPDF(pageImages, width, height) {
  const chunks = [];
  const xrefOffsets = [];
  let byteOffset = 0;
  const encoder = new TextEncoder();
  function write(data) {
    const bytes = typeof data === "string" ? encoder.encode(data) : data;
    chunks.push(bytes);
    byteOffset += bytes.length;
  }
  const DPI = 150;
  const pdfWidth = Math.round(width * 72 / DPI);
  const pdfHeight = Math.round(height * 72 / DPI);
  write("%PDF-1.7\n%\xE2\xE3\xCF\xD3\n");
  xrefOffsets.push(byteOffset);
  write("1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n");
  xrefOffsets.push(byteOffset);
  const pageRefs = pageImages.map((_, i) => `${i * 3 + 3} 0 R`).join(" ");
  write(`2 0 obj
<< /Type /Pages /Kids [ ${pageRefs} ] /Count ${pageImages.length} >>
endobj
`);
  for (let i = 0; i < pageImages.length; i++) {
    const pageObjId = i * 3 + 3;
    const contentsObjId = i * 3 + 4;
    const imageObjId = i * 3 + 5;
    const compressedPixels = deflate_1(pageImages[i]);
    xrefOffsets.push(byteOffset);
    write(`${pageObjId} 0 obj
<< /Type /Page
   /Parent 2 0 R
   /MediaBox [0 0 ${pdfWidth} ${pdfHeight}]
   /Contents ${contentsObjId} 0 R
   /Resources << /XObject << /Im1 ${imageObjId} 0 R >> >>
>>
endobj
`);
    const contents = `q
${pdfWidth} 0 0 ${pdfHeight} 0 0 cm
/Im1 Do
Q
`;
    xrefOffsets.push(byteOffset);
    write(`${contentsObjId} 0 obj
<< /Length ${contents.length} >>
stream
${contents}
endstream
endobj
`);
    xrefOffsets.push(byteOffset);
    write(`${imageObjId} 0 obj
<< /Type /XObject
   /Subtype /Image
   /Width ${width}
   /Height ${height}
   /ColorSpace /DeviceRGB
   /BitsPerComponent 8
   /Filter /FlateDecode
   /Length ${compressedPixels.length} >>
stream
`);
    write(compressedPixels);
    write("\nendstream\nendobj\n");
  }
  const xrefStart = byteOffset;
  write("xref\n");
  write(`0 ${xrefOffsets.length + 1}
`);
  write("0000000000 65535 f \n");
  for (const offset2 of xrefOffsets) {
    write(`${offset2.toString().padStart(10, "0")} 00000 n 
`);
  }
  write("trailer\n");
  write(`<< /Size ${xrefOffsets.length + 1} /Root 1 0 R >>
`);
  write("startxref\n");
  write(`${xrefStart}
`);
  write("%%EOF\n");
  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }
  return result;
}
async function convertNoteToPdf(noteData) {
  console.log(`[note-parser] Converting .note file: ${noteData.byteLength} bytes`);
  const reader = new BinaryReader(noteData);
  validateNoteFile(reader);
  const notebook = parseNotebook(reader);
  console.log(`[note-parser] Parsed notebook: ${notebook.pages.length} pages, ${notebook.width}x${notebook.height}`);
  const pageImages = [];
  for (let i = 0; i < notebook.pages.length; i++) {
    const page = notebook.pages[i];
    try {
      console.log(`[note-parser] Rendering page ${i + 1}/${notebook.pages.length}, layers: ${page.layers.map((l) => l.protocol).join(", ")}`);
      const rgba = await renderPage(reader, page, notebook.width, notebook.height);
      const rgb = rgbaToRgb(rgba, notebook.width, notebook.height);
      pageImages.push(rgb);
    } catch (err2) {
      console.error(`[note-parser] Failed to render page ${i + 1}:`, err2);
      throw new Error(`Failed to render page ${i + 1}: ${err2 instanceof Error ? err2.message : String(err2)}`);
    }
  }
  const pdfBytes = buildPDF(pageImages, notebook.width, notebook.height);
  console.log(`[note-parser] Generated PDF: ${pdfBytes.length} bytes`);
  return pdfBytes.buffer;
}
function getNoteInfo(noteData) {
  const reader = new BinaryReader(noteData);
  validateNoteFile(reader);
  const notebook = parseNotebook(reader);
  return {
    signature: notebook.signature,
    pageCount: notebook.pages.length,
    width: notebook.width,
    height: notebook.height
  };
}

// src/api/converter.ts
var { exec, execSync } = require("child_process");
var fs = require("fs");
var path = require("path");
var os = require("os");
var CLI_SEARCH_PATHS = [
  // User's home directory
  path.join(os.homedir(), ".local", "bin", "supernote_pdf"),
  path.join(os.homedir(), "bin", "supernote_pdf"),
  // System paths
  "/usr/local/bin/supernote_pdf",
  "/usr/bin/supernote_pdf",
  // Cargo install location
  path.join(os.homedir(), ".cargo", "bin", "supernote_pdf")
];
function execAsync(cmd) {
  return new Promise((resolve, reject) => {
    exec(cmd, (error, stdout, stderr) => {
      if (error) {
        reject(error);
      } else {
        resolve({ stdout, stderr });
      }
    });
  });
}
function findInPath() {
  try {
    const result = execSync("which supernote_pdf", { encoding: "utf8", timeout: 5e3 });
    return result.trim() || null;
  } catch (e) {
    return null;
  }
}
function findCliTool(configuredPath) {
  if (configuredPath) {
    try {
      fs.accessSync(configuredPath, fs.constants.X_OK);
      return configuredPath;
    } catch (e) {
    }
  }
  const pathResult = findInPath();
  if (pathResult) {
    return pathResult;
  }
  for (const searchPath of CLI_SEARCH_PATHS) {
    try {
      fs.accessSync(searchPath, fs.constants.X_OK);
      return searchPath;
    } catch (e) {
    }
  }
  return null;
}
var PdfConverter = class {
  constructor(mode = "cli", cliPath = "") {
    this.resolvedCliPath = null;
    this.mode = mode;
    this.cliPath = cliPath;
    if (mode === "cli") {
      this.resolvedCliPath = findCliTool(cliPath);
      if (this.resolvedCliPath) {
        console.log(`[converter] Found CLI tool at: ${this.resolvedCliPath}`);
      }
    }
  }
  /**
   * Update converter settings
   */
  setMode(mode, cliPath) {
    this.mode = mode;
    if (cliPath !== void 0) {
      this.cliPath = cliPath;
    }
    if (mode === "cli") {
      this.resolvedCliPath = findCliTool(this.cliPath);
    }
  }
  /**
   * Get the resolved CLI path (for display in settings)
   */
  getResolvedCliPath() {
    return this.resolvedCliPath;
  }
  /**
   * Check if the PDF conversion is available
   */
  async isToolAvailable() {
    if (this.mode === "builtin") {
      return true;
    }
    this.resolvedCliPath = findCliTool(this.cliPath);
    return this.resolvedCliPath !== null;
  }
  /**
   * Get the version of the converter
   */
  async getToolVersion() {
    if (this.mode === "builtin") {
      return "built-in v1.0.0 (TypeScript implementation - experimental)";
    }
    const cliPath = this.resolvedCliPath || findCliTool(this.cliPath);
    if (!cliPath) {
      return "CLI not found - install supernote_pdf or set path in settings";
    }
    try {
      const { stdout } = await execAsync(`"${cliPath}" --version`);
      return `CLI: ${stdout.trim()} (${cliPath})`;
    } catch (e) {
      return `CLI: version unknown (${cliPath})`;
    }
  }
  /**
   * Get information about a .note file without converting it
   * Note: Only works with built-in mode
   */
  getInfo(noteData) {
    return getNoteInfo(noteData);
  }
  /**
   * Convert a .note file to PDF
   * @param noteData The raw .note file data
   * @param noteId Optional identifier for logging
   * @returns ConversionResult with the PDF data or error information
   */
  async convert(noteData, noteId) {
    console.log(`[converter] Mode: ${this.mode}, CLI path: ${this.cliPath || "(not set)"}`);
    if (this.mode === "cli") {
      return this.convertWithCli(noteData, noteId);
    } else {
      return this.convertWithBuiltin(noteData, noteId);
    }
  }
  /**
   * Convert using the supernote_pdf CLI binary
   */
  async convertWithCli(noteData, noteId) {
    const startTime = Date.now();
    const fileId = noteId || "unknown";
    const cliPath = this.resolvedCliPath || findCliTool(this.cliPath);
    if (!cliPath) {
      console.error("[converter-cli] CLI tool not found");
      console.error("[converter-cli] Searched: configured path, PATH, and common locations");
      console.error("[converter-cli] Install supernote_pdf: cargo install supernote_pdf");
      return {
        success: false,
        error: "supernote_pdf CLI not found. Install it with: cargo install supernote_pdf (requires Rust). Or switch to built-in mode in settings.",
        conversionTimeMs: Date.now() - startTime
      };
    }
    this.resolvedCliPath = cliPath;
    if (!noteData || noteData.byteLength === 0) {
      console.error(`[converter-cli] File "${fileId}" is empty - download may have failed`);
      return {
        success: false,
        error: `File "${fileId}" is empty (0 bytes) - download may have failed`,
        conversionTimeMs: Date.now() - startTime
      };
    }
    console.log(`[converter-cli] Starting conversion of "${fileId}" (${noteData.byteLength} bytes) using ${cliPath}`);
    const tempDir = os.tmpdir();
    const inputPath = path.join(tempDir, `supernote_${Date.now()}_${Math.random().toString(36).slice(2)}.note`);
    const outputPath = inputPath.replace(".note", ".pdf");
    try {
      await fs.promises.writeFile(inputPath, Buffer.from(noteData));
      console.log(`[converter-cli] Wrote temp input file: ${inputPath}`);
      const cmd = `"${cliPath}" --input "${inputPath}" --output "${outputPath}"`;
      console.log(`[converter-cli] Running: ${cmd}`);
      const { stdout, stderr } = await execAsync(cmd);
      if (stdout)
        console.log(`[converter-cli] stdout: ${stdout}`);
      if (stderr)
        console.log(`[converter-cli] stderr: ${stderr}`);
      const pdfBuffer = await fs.promises.readFile(outputPath);
      const pdfData = pdfBuffer.buffer.slice(pdfBuffer.byteOffset, pdfBuffer.byteOffset + pdfBuffer.byteLength);
      const conversionTimeMs = Date.now() - startTime;
      console.log(`[converter-cli] Successfully converted "${fileId}" in ${conversionTimeMs}ms, PDF size: ${pdfData.byteLength} bytes`);
      return {
        success: true,
        pdfData,
        conversionTimeMs
      };
    } catch (error) {
      const conversionTimeMs = Date.now() - startTime;
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`[converter-cli] PDF conversion failed for "${fileId}":`, error);
      return {
        success: false,
        error: `CLI conversion failed: ${errorMsg}`,
        conversionTimeMs
      };
    } finally {
      try {
        await fs.promises.unlink(inputPath).catch(() => {
        });
        await fs.promises.unlink(outputPath).catch(() => {
        });
      } catch (e) {
      }
    }
  }
  /**
   * Convert using the built-in TypeScript implementation
   */
  async convertWithBuiltin(noteData, noteId) {
    const startTime = Date.now();
    const fileId = noteId || "unknown";
    if (!noteData || noteData.byteLength === 0) {
      console.error(`[converter-builtin] File "${fileId}" is empty - download may have failed`);
      return {
        success: false,
        error: `File "${fileId}" is empty (0 bytes) - download may have failed`,
        conversionTimeMs: Date.now() - startTime
      };
    }
    console.log(`[converter-builtin] Starting conversion of "${fileId}" (${noteData.byteLength} bytes)`);
    try {
      const info = getNoteInfo(noteData);
      const pdfData = await convertNoteToPdf(noteData);
      const conversionTimeMs = Date.now() - startTime;
      console.log(`[converter-builtin] Successfully converted "${fileId}" (${info.pageCount} pages) in ${conversionTimeMs}ms`);
      return {
        success: true,
        pdfData,
        conversionTimeMs,
        pageCount: info.pageCount
      };
    } catch (error) {
      const conversionTimeMs = Date.now() - startTime;
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`[converter-builtin] PDF conversion failed for "${fileId}":`, {
        error: errorMsg,
        fileSize: noteData.byteLength,
        conversionTimeMs
      });
      return {
        success: false,
        error: `${errorMsg} (file: ${fileId}, size: ${noteData.byteLength} bytes)`,
        conversionTimeMs
      };
    }
  }
  /**
   * Convert multiple .note files in sequence (legacy method)
   */
  async convertBatch(notes, onProgress) {
    const results = /* @__PURE__ */ new Map();
    for (let i = 0; i < notes.length; i++) {
      const { id, data } = notes[i];
      if (onProgress) {
        onProgress(i + 1, notes.length, id);
      }
      const result = await this.convert(data, id);
      results.set(id, result);
    }
    return results;
  }
  /**
   * Check if batch directory conversion is available (CLI mode only)
   */
  canBatchConvert() {
    return this.mode === "cli" && this.resolvedCliPath !== null;
  }
  /**
   * Convert an entire directory of .note files to PDFs using CLI batch mode.
   * This is MUCH faster than converting files one by one.
   * 
   * @param inputDir Directory containing .note files (can have subdirectories)
   * @param outputDir Directory where PDFs will be written (preserves folder structure)
   * @returns BatchConversionResult with success status and timing info
   */
  async convertDirectory(inputDir, outputDir) {
    const startTime = Date.now();
    if (this.mode !== "cli") {
      return {
        success: false,
        outputDir,
        error: "Batch directory conversion only available in CLI mode",
        conversionTimeMs: Date.now() - startTime
      };
    }
    const cliPath = this.resolvedCliPath || findCliTool(this.cliPath);
    if (!cliPath) {
      return {
        success: false,
        outputDir,
        error: "supernote_pdf CLI not found",
        conversionTimeMs: Date.now() - startTime
      };
    }
    console.log(`[converter-cli] Starting batch conversion: ${inputDir} -> ${outputDir}`);
    try {
      const cmd = `"${cliPath}" --input "${inputDir}" --output "${outputDir}"`;
      console.log(`[converter-cli] Running: ${cmd}`);
      const { stdout, stderr } = await execAsync(cmd);
      if (stdout)
        console.log(`[converter-cli] stdout: ${stdout}`);
      if (stderr)
        console.log(`[converter-cli] stderr: ${stderr}`);
      const conversionTimeMs = Date.now() - startTime;
      let fileCount = 0;
      try {
        const countPdfs = (dir) => {
          let count = 0;
          const entries = fs.readdirSync(dir, { withFileTypes: true });
          for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
              count += countPdfs(fullPath);
            } else if (entry.name.endsWith(".pdf")) {
              count++;
            }
          }
          return count;
        };
        fileCount = countPdfs(outputDir);
      } catch (e) {
      }
      console.log(`[converter-cli] Batch conversion complete: ${fileCount} PDFs in ${conversionTimeMs}ms`);
      return {
        success: true,
        outputDir,
        conversionTimeMs,
        fileCount
      };
    } catch (error) {
      const conversionTimeMs = Date.now() - startTime;
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`[converter-cli] Batch conversion failed:`, error);
      return {
        success: false,
        outputDir,
        error: `CLI batch conversion failed: ${errorMsg}`,
        conversionTimeMs
      };
    }
  }
  /**
   * Create a temporary directory for batch operations
   * @param createDir - If true, creates the directory. If false, just returns the path (for CLI output dirs)
   */
  createTempDir(prefix, createDir = true) {
    const tempBase = os.tmpdir();
    const dirName = `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2)}`;
    const tempDir = path.join(tempBase, dirName);
    if (createDir) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    return tempDir;
  }
  /**
   * Clean up a temporary directory
   */
  async cleanupTempDir(tempDir) {
    try {
      const removeRecursive = async (dir) => {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          if (entry.isDirectory()) {
            await removeRecursive(fullPath);
          } else {
            await fs.promises.unlink(fullPath);
          }
        }
        await fs.promises.rmdir(dir);
      };
      await removeRecursive(tempDir);
    } catch (error) {
      console.warn(`[converter] Failed to cleanup temp dir ${tempDir}:`, error);
    }
  }
  /**
   * Write a .note file to a temp directory, preserving relative path
   */
  async writeNoteToTempDir(tempDir, relativePath, data) {
    const fullPath = path.join(tempDir, relativePath);
    const dir = path.dirname(fullPath);
    await fs.promises.mkdir(dir, { recursive: true });
    await fs.promises.writeFile(fullPath, Buffer.from(data));
    return fullPath;
  }
};

// src/ui/settings-tab.ts
var SupernoteSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Supernote Companion Settings" });
    this.createConnectionSettings(containerEl);
    this.createSyncSettings(containerEl);
    this.createUpdateSettings(containerEl);
    this.createExportSettings(containerEl);
    this.createAdvancedSettings(containerEl);
  }
  createConnectionSettings(containerEl) {
    containerEl.createEl("h2", { text: "Supernote Device Connection" });
    containerEl.createEl("p", {
      text: 'Connect to your Supernote device via WiFi. Enable "Browse & Access" on your Supernote to get the IP address.',
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Device IP address").setDesc("The IP address shown when you enable Browse & Access on your Supernote (e.g., 192.168.1.100)").addText(
      (text) => text.setPlaceholder("192.168.1.100").setValue(this.plugin.settings.deviceIp).onChange(async (value) => {
        let ip = value.trim();
        ip = ip.replace(/^https?:\/\//, "");
        ip = ip.replace(/:\d+\/?$/, "");
        ip = ip.replace(/\/$/, "");
        this.plugin.settings.deviceIp = ip;
        this.plugin.resetAPIClient();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Device port").setDesc("The port for Browse & Access (default: 8089)").addText(
      (text) => text.setPlaceholder("8089").setValue(this.plugin.settings.devicePort.toString()).onChange(async (value) => {
        const port = parseInt(value, 10);
        if (!isNaN(port) && port > 0 && port <= 65535) {
          this.plugin.settings.devicePort = port;
          this.plugin.resetAPIClient();
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Test connection").setDesc("Verify that the plugin can connect to your Supernote device").addButton(
      (button) => button.setButtonText("Test Connection").setCta().onClick(async () => {
        if (!this.plugin.settings.deviceIp) {
          new import_obsidian2.Notice("Please enter your Supernote device IP address first.");
          return;
        }
        button.setDisabled(true);
        button.setButtonText("Testing...");
        try {
          const client = this.plugin.getAPIClient();
          const status = await client.checkConnection();
          if (status.connected) {
            new import_obsidian2.Notice(`Connected to Supernote at ${this.plugin.settings.deviceIp}:${this.plugin.settings.devicePort}`);
          } else {
            new import_obsidian2.Notice(`Connection failed: ${status.error || "Unknown error"}

Make sure Browse & Access is enabled on your Supernote.`);
          }
        } catch (error) {
          new import_obsidian2.Notice(`Connection error: ${error instanceof Error ? error.message : "Unknown error"}`);
        } finally {
          button.setDisabled(false);
          button.setButtonText("Test Connection");
        }
      })
    );
  }
  createSyncSettings(containerEl) {
    containerEl.createEl("h2", { text: "Sync Configuration" });
    new import_obsidian2.Setting(containerEl).setName("Import mode").setDesc("How to import notes from your Supernote").addDropdown(
      (dropdown) => dropdown.addOption("pdf-only", "PDF only (recommended)").addOption("markdown-with-pdf", "Markdown + PDF attachment").addOption("markdown-only", "Markdown only (no PDF)").setValue(this.plugin.settings.importMode).onChange(async (value) => {
        this.plugin.settings.importMode = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Notes folder").setDesc("Vault folder where imported files will be stored").addText(
      (text) => text.setPlaceholder("/Supernote").setValue(this.plugin.settings.notesFolder).onChange(async (value) => {
        this.plugin.settings.notesFolder = value;
        await this.plugin.saveSettings();
      })
    );
    if (this.plugin.settings.importMode === "markdown-with-pdf") {
      new import_obsidian2.Setting(containerEl).setName("PDF folder").setDesc("Vault folder where PDF attachments will be stored").addText(
        (text) => text.setPlaceholder("/Supernote/PDFs").setValue(this.plugin.settings.pdfFolder).onChange(async (value) => {
          this.plugin.settings.pdfFolder = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian2.Setting(containerEl).setName("Preserve folder structure").setDesc("Mirror the folder structure from your Supernote (e.g., /Note/Work/Projects \u2192 Supernote/Work/Projects)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.preserveFolderStructure).onChange(async (value) => {
        this.plugin.settings.preserveFolderStructure = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Filename template").setDesc("Template for imported filenames. Variables: {name}, {date}, {created}, {modified}, {datetime}, {year}, {month}, {day}, {pages}, {id}").addText(
      (text) => text.setPlaceholder("{name}").setValue(this.plugin.settings.filenameTemplate).onChange(async (value) => {
        this.plugin.settings.filenameTemplate = value || "{name}";
        await this.plugin.saveSettings();
      })
    );
    const templateHint = containerEl.createDiv("setting-item-description");
    templateHint.style.marginLeft = "20px";
    templateHint.style.marginBottom = "15px";
    templateHint.innerHTML = `
            <strong>Examples:</strong><br>
            <code>{name}</code> \u2192 "Meeting Notes"<br>
            <code>{date} {name}</code> \u2192 "2024-01-15 Meeting Notes"<br>
            <code>{year}/{month}/{name}</code> \u2192 "2024/01/Meeting Notes"
        `;
    if (this.plugin.settings.lastSync > 0) {
      const lastSyncDate = new Date(this.plugin.settings.lastSync);
      new import_obsidian2.Setting(containerEl).setName("Last sync").setDesc(`Last synced: ${lastSyncDate.toLocaleString()}`);
    }
  }
  createUpdateSettings(containerEl) {
    containerEl.createEl("h2", { text: "Update Behavior" });
    new import_obsidian2.Setting(containerEl).setName("Update modified files").setDesc("How to handle files that have been modified locally since last sync").addDropdown(
      (dropdown) => dropdown.addOption("skip", "Skip modified files (safest)").addOption("ask", "Ask me each time").addOption("overwrite", "Always overwrite (dangerous)").setValue(this.plugin.settings.updateModifiedFiles).onChange(async (value) => {
        this.plugin.settings.updateModifiedFiles = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Default update mode").setDesc("Choose what to update when syncing existing notes").addDropdown(
      (dropdown) => dropdown.addOption("all", "Update everything").addOption("frontmatter-only", "Update frontmatter only").addOption("content-only", "Update content only").addOption("specific-frontmatter", "Update specific frontmatter fields").setValue(this.plugin.settings.updateMode).onChange(async (value) => {
        this.plugin.settings.updateMode = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.updateMode === "specific-frontmatter") {
      this.createFieldSelector(containerEl);
    }
    new import_obsidian2.Setting(containerEl).setName("Preserve custom fields").setDesc("Keep user-added frontmatter fields during updates").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.preserveCustomFields).onChange(async (value) => {
        this.plugin.settings.preserveCustomFields = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Tags merge strategy").setDesc("How to handle tags when updating").addDropdown(
      (dropdown) => dropdown.addOption("replace", "Replace (overwrite all tags)").addOption("merge", "Merge (add new tags, keep existing)").setValue(this.plugin.settings.tagsMergeStrategy).onChange(async (value) => {
        this.plugin.settings.tagsMergeStrategy = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createFieldSelector(containerEl) {
    const fieldsContainer = containerEl.createDiv("specific-fields-container");
    fieldsContainer.style.marginLeft = "20px";
    fieldsContainer.style.padding = "15px";
    fieldsContainer.style.backgroundColor = "var(--background-secondary)";
    fieldsContainer.style.borderRadius = "8px";
    fieldsContainer.style.marginBottom = "15px";
    fieldsContainer.createEl("div", {
      text: "Select which frontmatter fields to update:",
      cls: "setting-item-description"
    }).style.marginBottom = "10px";
    const fieldOptions = [
      { key: "name", label: "Name", desc: "Note title" },
      { key: "source", label: "Source", desc: "Original path on Supernote" },
      { key: "date", label: "Date", desc: "Creation and modification dates" },
      { key: "pageCount", label: "Page Count", desc: "Number of pages" },
      { key: "size", label: "Size", desc: "File size" },
      { key: "tags", label: "Tags", desc: "Note tags" }
    ];
    fieldOptions.forEach((field) => {
      new import_obsidian2.Setting(fieldsContainer).setName(field.label).setDesc(field.desc).addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.specificFrontmatterFields.includes(field.key)).onChange(async (value) => {
          if (value) {
            if (!this.plugin.settings.specificFrontmatterFields.includes(field.key)) {
              this.plugin.settings.specificFrontmatterFields.push(field.key);
            }
          } else {
            this.plugin.settings.specificFrontmatterFields = this.plugin.settings.specificFrontmatterFields.filter((f) => f !== field.key);
          }
          await this.plugin.saveSettings();
        })
      );
    });
  }
  createExportSettings(containerEl) {
    if (this.plugin.settings.importMode === "pdf-only") {
      return;
    }
    containerEl.createEl("h2", { text: "Markdown Options" });
    if (this.plugin.settings.importMode === "markdown-with-pdf") {
      new import_obsidian2.Setting(containerEl).setName("Attach PDF").setDesc("Convert .note files to PDF and attach them to note entries").addToggle(
        (toggle) => toggle.setValue(this.plugin.settings.attachPdf).onChange(async (value) => {
          this.plugin.settings.attachPdf = value;
          await this.plugin.saveSettings();
        })
      );
    }
    new import_obsidian2.Setting(containerEl).setName("Include thumbnail").setDesc("Embed a thumbnail preview image in the note (not available from device API)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.includeThumbnail).onChange(async (value) => {
        this.plugin.settings.includeThumbnail = value;
        await this.plugin.saveSettings();
      })
    );
  }
  createAdvancedSettings(containerEl) {
    const advancedContainer = containerEl.createDiv("advanced-settings-container");
    advancedContainer.style.marginTop = "30px";
    advancedContainer.style.borderTop = "1px solid var(--background-modifier-border)";
    advancedContainer.style.paddingTop = "20px";
    const advancedHeader = advancedContainer.createEl("h2", {
      text: "\u25B6 Advanced Settings",
      cls: "advanced-header"
    });
    advancedHeader.style.cursor = "pointer";
    advancedHeader.style.userSelect = "none";
    const advancedContent = advancedContainer.createDiv("advanced-content");
    advancedContent.style.display = "none";
    advancedContent.style.marginTop = "15px";
    advancedHeader.addEventListener("click", () => {
      const isHidden = advancedContent.style.display === "none";
      advancedContent.style.display = isHidden ? "block" : "none";
      advancedHeader.setText(isHidden ? "\u25BC Advanced Settings" : "\u25B6 Advanced Settings");
    });
    advancedContent.createEl("h3", { text: "PDF Converter" });
    const converterDesc = advancedContent.createDiv("setting-item-description");
    converterDesc.style.marginBottom = "15px";
    converterDesc.innerHTML = `
            <strong>CLI (Recommended):</strong> Uses the supernote_pdf Rust binary for reliable conversion.<br>
            <strong>Built-in:</strong> Uses TypeScript implementation (experimental, may have rendering issues).
        `;
    new import_obsidian2.Setting(advancedContent).setName("Converter mode").setDesc("Choose how to convert .note files to PDF").addDropdown(
      (dropdown) => dropdown.addOption("cli", "CLI binary (recommended)").addOption("builtin", "Built-in TypeScript (experimental)").setValue(this.plugin.settings.converterMode).onChange(async (value) => {
        this.plugin.settings.converterMode = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.converterMode === "cli") {
      new import_obsidian2.Setting(advancedContent).setName("CLI binary path").setDesc("Path to the supernote_pdf binary (e.g., /usr/local/bin/supernote_pdf)").addText(
        (text) => text.setPlaceholder("/path/to/supernote_pdf").setValue(this.plugin.settings.converterPath).onChange(async (value) => {
          this.plugin.settings.converterPath = value.trim();
          await this.plugin.saveSettings();
        })
      );
      new import_obsidian2.Setting(advancedContent).setName("Test converter").setDesc("Verify that the CLI binary is accessible").addButton(
        (button) => button.setButtonText("Test CLI").onClick(async () => {
          if (!this.plugin.settings.converterPath) {
            new import_obsidian2.Notice("Please set the CLI binary path first.");
            return;
          }
          button.setDisabled(true);
          button.setButtonText("Testing...");
          try {
            const converter = new PdfConverter(
              this.plugin.settings.converterMode,
              this.plugin.settings.converterPath
            );
            const available = await converter.isToolAvailable();
            const version = await converter.getToolVersion();
            if (available) {
              new import_obsidian2.Notice(`CLI converter working! ${version}`);
            } else {
              new import_obsidian2.Notice("CLI binary not found or not executable. Check the path.");
            }
          } catch (error) {
            new import_obsidian2.Notice(`Error: ${error instanceof Error ? error.message : "Unknown error"}`);
          } finally {
            button.setDisabled(false);
            button.setButtonText("Test CLI");
          }
        })
      );
    } else {
      new import_obsidian2.Setting(advancedContent).setName("Converter status").setDesc("Built-in TypeScript converter (experimental)").addButton(
        (button) => button.setButtonText("Check Version").onClick(async () => {
          const converter = new PdfConverter("builtin", "");
          const version = await converter.getToolVersion();
          new import_obsidian2.Notice(`PDF Converter: ${version}`);
        })
      );
    }
    new import_obsidian2.Setting(advancedContent).setName("Connection timeout").setDesc("Timeout for device connections in milliseconds").addText(
      (text) => text.setPlaceholder("10000").setValue(this.plugin.settings.connectionTimeout.toString()).onChange(async (value) => {
        const timeout = parseInt(value, 10);
        if (!isNaN(timeout) && timeout > 0) {
          this.plugin.settings.connectionTimeout = timeout;
          await this.plugin.saveSettings();
        }
      })
    );
    new import_obsidian2.Setting(advancedContent).setName("Clear trashed notes").setDesc(`${this.plugin.settings.trashedNoteIds.length} note(s) currently in trash`).addButton(
      (button) => button.setButtonText("Clear Trash").setWarning().onClick(async () => {
        this.plugin.settings.trashedNoteIds = [];
        await this.plugin.saveSettings();
        new import_obsidian2.Notice("Trash cleared. All notes will appear in future syncs.");
        this.display();
      })
    );
    new import_obsidian2.Setting(advancedContent).setName("Reset sync timestamp").setDesc("Reset the last sync time (useful for forcing a full resync)").addButton(
      (button) => button.setButtonText("Reset").setWarning().onClick(async () => {
        this.plugin.settings.lastSync = 0;
        await this.plugin.saveSettings();
        new import_obsidian2.Notice("Sync timestamp reset. All notes will be treated as updated.");
        this.display();
      })
    );
    new import_obsidian2.Setting(advancedContent).setName("Debug mode").setDesc("Enable verbose logging and mock client for testing without a real device").addToggle(
      (toggle) => toggle.setValue(window.SUPERNOTE_DEBUG || false).onChange((value) => {
        window.SUPERNOTE_DEBUG = value;
        this.plugin.resetAPIClient();
        new import_obsidian2.Notice(`Debug mode ${value ? "enabled" : "disabled"}`);
      })
    );
  }
};

// src/ui/sync-status-modal.ts
var import_obsidian3 = require("obsidian");

// src/utils/markdown.ts
function generateMarkdown(note, options, pdfVaultPath, thumbnailBase64) {
  const frontmatter = generateFrontmatter(note, pdfVaultPath);
  const body = generateBody(note, options, pdfVaultPath, thumbnailBase64);
  return `---
${frontmatter}---

${body}`;
}
function generateFrontmatter(note, pdfVaultPath) {
  const lines = [];
  lines.push(`name: "${escapeYamlString(note.name)}"`);
  lines.push(`supernote_id: "${note.id}"`);
  lines.push(`source: "${escapeYamlString(note.path)}"`);
  const createdDate = formatDate(note.createdAt);
  const modifiedDate = formatDate(note.modifiedAt);
  lines.push(`created: ${createdDate}`);
  lines.push(`modified: ${modifiedDate}`);
  if (note.pageCount !== void 0) {
    lines.push(`pages: ${note.pageCount}`);
  }
  lines.push(`size: "${formatFileSize(note.size)}"`);
  if (pdfVaultPath) {
    lines.push(`pdf_attachment: "${escapeYamlString(pdfVaultPath)}"`);
  }
  lines.push(`tags:`);
  lines.push(`  - supernote`);
  return lines.join("\n") + "\n";
}
function generateBody(note, options, pdfVaultPath, thumbnailBase64) {
  const sections = [];
  sections.push(`# ${note.name}
`);
  sections.push(`## Note Information
`);
  sections.push(`| Property | Value |`);
  sections.push(`|----------|-------|`);
  sections.push(`| **Source** | \`${note.path}\` |`);
  sections.push(`| **Created** | ${formatDateReadable(note.createdAt)} |`);
  sections.push(`| **Modified** | ${formatDateReadable(note.modifiedAt)} |`);
  if (note.pageCount !== void 0) {
    sections.push(`| **Pages** | ${note.pageCount} |`);
  }
  sections.push(`| **Size** | ${formatFileSize(note.size)} |`);
  sections.push("");
  if (options.attachPdf && pdfVaultPath) {
    sections.push(`## PDF Attachment
`);
    sections.push(`![[${pdfVaultPath}]]
`);
  }
  if (options.includeThumbnail && thumbnailBase64) {
    sections.push(`## Preview
`);
    sections.push(`![Thumbnail](${thumbnailBase64})
`);
  }
  sections.push(`---
`);
  sections.push(`## Notes
`);
  sections.push(`*Add your notes and annotations here...*
`);
  return sections.join("\n");
}
function generateFilename(note, template) {
  const result = applyFilenameTemplate(note, template || "{date} {name}");
  return `${result}.md`;
}
function generatePdfFilename(note, template) {
  const result = applyFilenameTemplate(note, template || "{date} {name}");
  return `${result}.pdf`;
}
function applyFilenameTemplate(note, template) {
  var _a;
  const modifiedDate = new Date(note.modifiedAt);
  const createdDate = new Date(note.createdAt);
  const cleanName = note.name.replace(/\.note$/i, "");
  const replacements = {
    "{name}": cleanName,
    "{date}": formatDate(note.modifiedAt),
    "{created}": formatDate(note.createdAt),
    "{modified}": formatDate(note.modifiedAt),
    "{datetime}": formatDateTime(note.modifiedAt),
    "{pages}": ((_a = note.pageCount) == null ? void 0 : _a.toString()) || "0",
    "{id}": note.id,
    "{year}": modifiedDate.getFullYear().toString(),
    "{month}": (modifiedDate.getMonth() + 1).toString().padStart(2, "0"),
    "{day}": modifiedDate.getDate().toString().padStart(2, "0")
  };
  let result = template;
  for (const [key, value] of Object.entries(replacements)) {
    result = result.split(key).join(value);
  }
  return sanitizeFilename(result);
}
function formatDateTime(dateString) {
  const date = new Date(dateString);
  const datePart = date.toISOString().split("T")[0];
  const hours = date.getHours().toString().padStart(2, "0");
  const minutes = date.getMinutes().toString().padStart(2, "0");
  return `${datePart}_${hours}-${minutes}`;
}
function sanitizeFilename(name) {
  return name.replace(/[\\/:*?"<>|]/g, "").replace(/\s+/g, " ").trim();
}
function escapeYamlString(str) {
  return str.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}
function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toISOString().split("T")[0];
}
function formatDateReadable(dateString) {
  const date = new Date(dateString);
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit"
  });
}
function formatFileSize(bytes) {
  if (bytes === 0)
    return "0 B";
  const units = ["B", "KB", "MB", "GB"];
  const k = 1024;
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${units[i]}`;
}
function updateFrontmatter(existingContent, newFrontmatter, preserveCustomFields, fieldsToUpdate) {
  const frontmatterMatch = existingContent.match(/^---\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    const yaml = objectToYaml(newFrontmatter);
    return `---
${yaml}---

${existingContent}`;
  }
  const existingYaml = frontmatterMatch[1];
  const existingFields = parseSimpleYaml(existingYaml);
  const knownFields = ["name", "supernote_id", "source", "created", "modified", "pages", "size", "pdf_attachment", "tags"];
  let fieldsToProcess;
  if (fieldsToUpdate && fieldsToUpdate.length > 0) {
    fieldsToProcess = fieldsToUpdate;
  } else {
    fieldsToProcess = Object.keys(newFrontmatter);
  }
  const mergedFields = { ...existingFields };
  for (const field of fieldsToProcess) {
    if (field in newFrontmatter) {
      mergedFields[field] = newFrontmatter[field];
    }
  }
  if (preserveCustomFields) {
    for (const field of Object.keys(existingFields)) {
      if (!knownFields.includes(field) && !(field in mergedFields)) {
        mergedFields[field] = existingFields[field];
      }
    }
  }
  const newYaml = objectToYaml(mergedFields);
  const bodyContent = existingContent.slice(frontmatterMatch[0].length);
  return `---
${newYaml}---${bodyContent}`;
}
function objectToYaml(obj) {
  const lines = [];
  for (const [key, value] of Object.entries(obj)) {
    if (Array.isArray(value)) {
      lines.push(`${key}:`);
      for (const item of value) {
        lines.push(`  - ${typeof item === "string" ? `"${escapeYamlString(item)}"` : item}`);
      }
    } else if (typeof value === "string") {
      lines.push(`${key}: "${escapeYamlString(value)}"`);
    } else if (typeof value === "number" || typeof value === "boolean") {
      lines.push(`${key}: ${value}`);
    } else if (value === null || value === void 0) {
      lines.push(`${key}: `);
    }
  }
  return lines.join("\n") + "\n";
}
function parseSimpleYaml(yaml) {
  const result = {};
  const lines = yaml.split("\n");
  let currentKey = "";
  let currentArray = [];
  let isArray = false;
  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed)
      continue;
    if (trimmed.startsWith("- ")) {
      if (isArray) {
        const value2 = trimmed.slice(2).replace(/^["']|["']$/g, "");
        currentArray.push(value2);
      }
      continue;
    }
    if (isArray && currentKey) {
      result[currentKey] = currentArray;
      isArray = false;
      currentArray = [];
    }
    const colonIndex = trimmed.indexOf(":");
    if (colonIndex === -1)
      continue;
    const key = trimmed.slice(0, colonIndex).trim();
    const value = trimmed.slice(colonIndex + 1).trim();
    if (!key)
      continue;
    currentKey = key;
    if (value === "" || value === "|" || value === ">") {
      isArray = true;
      currentArray = [];
    } else {
      result[key] = value.replace(/^["']|["']$/g, "");
    }
  }
  if (isArray && currentKey) {
    result[currentKey] = currentArray;
  }
  return result;
}

// src/ui/sync-status-modal.ts
var SyncStatusModal = class extends import_obsidian3.Modal {
  constructor(app, status) {
    super(app);
    this.status = status;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "80%";
    this.modalEl.style.maxWidth = "1000px";
    this.titleEl.setText("Sync Status");
    const total = this.status.new.length + this.status.updated.length + this.status.synced.length;
    const summaryEl = contentEl.createEl("div", { cls: "sync-status-summary" });
    summaryEl.style.marginBottom = "20px";
    summaryEl.style.padding = "15px";
    summaryEl.style.backgroundColor = "var(--background-secondary)";
    summaryEl.style.borderRadius = "8px";
    summaryEl.innerHTML = `
            <div style="display: flex; justify-content: space-around; text-align: center;">
                <div>
                    <div style="font-size: 2em; font-weight: bold;">${total}</div>
                    <div style="color: var(--text-muted);">Total Notes</div>
                </div>
                <div>
                    <div style="font-size: 2em; font-weight: bold; color: var(--text-accent);">${this.status.new.length}</div>
                    <div style="color: var(--text-muted);">New</div>
                </div>
                <div>
                    <div style="font-size: 2em; font-weight: bold; color: var(--color-orange);">${this.status.updated.length}</div>
                    <div style="color: var(--text-muted);">Updated</div>
                </div>
                <div>
                    <div style="font-size: 2em; font-weight: bold; color: var(--color-green);">${this.status.synced.length}</div>
                    <div style="color: var(--text-muted);">Synced</div>
                </div>
            </div>
        `;
    const scrollContainer = contentEl.createDiv("sync-status-scroll");
    scrollContainer.style.maxHeight = "500px";
    scrollContainer.style.overflowY = "auto";
    if (this.status.new.length > 0) {
      this.createSection(scrollContainer, "New Notes", this.status.new, "var(--text-accent)");
    }
    if (this.status.updated.length > 0) {
      this.createSection(scrollContainer, "Updated Notes", this.status.updated, "var(--color-orange)");
    }
    if (this.status.synced.length > 0) {
      this.createCollapsibleSection(scrollContainer, "Already Synced", this.status.synced, "var(--color-green)");
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    const closeButton = buttonContainer.createEl("button", { text: "Close" });
    closeButton.onclick = () => this.close();
  }
  createSection(container, title, notes, accentColor) {
    const section = container.createDiv("sync-status-section");
    section.style.marginBottom = "20px";
    const header = section.createEl("h3", { text: `${title} (${notes.length})` });
    header.style.borderLeft = `4px solid ${accentColor}`;
    header.style.paddingLeft = "10px";
    header.style.marginBottom = "10px";
    section.appendChild(this.createNotesTable(notes));
  }
  createCollapsibleSection(container, title, notes, accentColor) {
    const section = container.createDiv("sync-status-section");
    section.style.marginBottom = "20px";
    const header = section.createEl("h3", { text: `\u25B6 ${title} (${notes.length})` });
    header.style.borderLeft = `4px solid ${accentColor}`;
    header.style.paddingLeft = "10px";
    header.style.marginBottom = "10px";
    header.style.cursor = "pointer";
    header.style.userSelect = "none";
    const tableContainer = section.createDiv();
    tableContainer.style.display = "none";
    tableContainer.appendChild(this.createNotesTable(notes));
    header.addEventListener("click", () => {
      const isHidden = tableContainer.style.display === "none";
      tableContainer.style.display = isHidden ? "block" : "none";
      header.setText(`${isHidden ? "\u25BC" : "\u25B6"} ${title} (${notes.length})`);
    });
  }
  createNotesTable(notes) {
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    const headers = ["Name", "Path", "Modified", "Pages", "Size"];
    headers.forEach((headerText) => {
      const th = document.createElement("th");
      th.textContent = headerText;
      th.style.textAlign = "left";
      th.style.padding = "8px 12px";
      th.style.borderBottom = "2px solid var(--background-modifier-border)";
      th.style.fontWeight = "600";
      th.style.fontSize = "0.85em";
      th.style.textTransform = "uppercase";
      th.style.letterSpacing = "0.5px";
      th.style.color = "var(--text-muted)";
      headerRow.appendChild(th);
    });
    const tbody = table.createTBody();
    notes.forEach((note, index) => {
      var _a;
      const row = tbody.insertRow();
      row.style.backgroundColor = index % 2 === 0 ? "transparent" : "var(--background-secondary-alt)";
      const nameCell = row.insertCell();
      nameCell.textContent = note.name;
      nameCell.style.padding = "10px 12px";
      nameCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      nameCell.style.fontWeight = "500";
      const pathCell = row.insertCell();
      pathCell.textContent = this.truncatePath(note.path);
      pathCell.title = note.path;
      pathCell.style.padding = "10px 12px";
      pathCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      pathCell.style.color = "var(--text-muted)";
      pathCell.style.fontSize = "0.9em";
      const dateCell = row.insertCell();
      dateCell.textContent = this.formatDate(note.modifiedAt);
      dateCell.style.padding = "10px 12px";
      dateCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      const pagesCell = row.insertCell();
      pagesCell.textContent = ((_a = note.pageCount) == null ? void 0 : _a.toString()) || "-";
      pagesCell.style.padding = "10px 12px";
      pagesCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      pagesCell.style.textAlign = "center";
      const sizeCell = row.insertCell();
      sizeCell.textContent = formatFileSize(note.size);
      sizeCell.style.padding = "10px 12px";
      sizeCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      sizeCell.style.textAlign = "right";
    });
    return table;
  }
  formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric"
    });
  }
  truncatePath(path3, maxLength = 40) {
    if (path3.length <= maxLength)
      return path3;
    const start = path3.slice(0, 15);
    const end = path3.slice(-20);
    return `${start}...${end}`;
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/confirmation-modal.ts
var import_obsidian4 = require("obsidian");
var ConfirmationModal = class extends import_obsidian4.Modal {
  constructor(app, notes, actionType, onConfirm, onCancel, onTrash, lastSync, localNotes) {
    super(app);
    // Keyboard navigation
    this.currentRowIndex = 0;
    this.tableRows = [];
    // Button references
    this.confirmButton = null;
    this.selectAllBtn = null;
    this.deselectAllBtn = null;
    this.trashAllBtn = null;
    this.notes = notes;
    this.actionType = actionType;
    this.lastSync = lastSync;
    this.localNotes = localNotes;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
    this.onTrash = onTrash;
    this.selectedNotes = new Set(notes.map((n) => n.id));
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "85%";
    this.modalEl.style.maxWidth = "1100px";
    this.titleEl.setText(this.getActionTitle());
    const descEl = contentEl.createEl("p", {
      text: this.getActionDescription(),
      cls: "confirmation-modal-desc"
    });
    descEl.style.marginBottom = "10px";
    descEl.style.color = "var(--text-muted)";
    const helpText = contentEl.createEl("p", {
      text: "Keyboard: \u2191\u2193 to navigate, Space/Enter to toggle selection",
      cls: "setting-item-description"
    });
    helpText.style.marginBottom = "15px";
    helpText.style.fontSize = "0.85em";
    helpText.style.fontStyle = "italic";
    const tableContainer = contentEl.createDiv("confirmation-table-container");
    tableContainer.style.maxHeight = "450px";
    tableContainer.style.overflowY = "auto";
    tableContainer.style.border = "1px solid var(--background-modifier-border)";
    tableContainer.style.borderRadius = "6px";
    tableContainer.appendChild(this.createNotesTable());
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "space-between";
    buttonContainer.style.flexWrap = "wrap";
    const leftButtons = buttonContainer.createDiv();
    leftButtons.style.display = "flex";
    leftButtons.style.gap = "8px";
    this.selectAllBtn = leftButtons.createEl("button", {
      text: "Select All",
      cls: "mod-muted"
    });
    this.selectAllBtn.onclick = () => this.selectAll();
    this.deselectAllBtn = leftButtons.createEl("button", {
      text: "Deselect All",
      cls: "mod-muted"
    });
    this.deselectAllBtn.onclick = () => this.deselectAll();
    if (this.actionType === "import") {
      this.trashAllBtn = leftButtons.createEl("button", {
        text: "Trash Selected",
        cls: "mod-warning"
      });
      this.trashAllBtn.style.color = "var(--text-error)";
      this.trashAllBtn.onclick = () => this.handleTrashAllSelected();
    }
    const rightButtons = buttonContainer.createDiv();
    rightButtons.style.display = "flex";
    rightButtons.style.gap = "8px";
    const cancelButton = rightButtons.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => {
      this.close();
      this.onCancel();
    };
    this.confirmButton = rightButtons.createEl("button", {
      text: `Confirm (${this.selectedNotes.size} selected)`,
      cls: "mod-cta"
    });
    this.confirmButton.onclick = () => {
      const selected = this.notes.filter((n) => this.selectedNotes.has(n.id));
      this.close();
      this.onConfirm(selected);
    };
    this.updateButtonStates();
    this.registerKeyboardHandlers();
  }
  createNotesTable() {
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";
    const showStatusColumn = this.actionType === "update" && this.lastSync && this.localNotes;
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    const headers = showStatusColumn ? ["", "Name", "Path", "Modified", "Pages", "Size", "Status"] : ["", "Name", "Path", "Modified", "Pages", "Size"];
    headers.forEach((headerText, index) => {
      const th = document.createElement("th");
      th.textContent = headerText;
      th.style.textAlign = index === 0 ? "center" : "left";
      th.style.padding = "10px 12px";
      th.style.borderBottom = "2px solid var(--background-modifier-border)";
      th.style.fontWeight = "600";
      th.style.fontSize = "0.85em";
      th.style.position = "sticky";
      th.style.top = "0";
      th.style.backgroundColor = "var(--background-primary)";
      th.style.zIndex = "10";
      if (headerText) {
        th.style.textTransform = "uppercase";
        th.style.letterSpacing = "0.5px";
        th.style.color = "var(--text-muted)";
      }
      headerRow.appendChild(th);
    });
    const tbody = table.createTBody();
    this.tableRows = [];
    this.notes.forEach((note, index) => {
      var _a;
      const row = tbody.insertRow();
      this.tableRows.push(row);
      row.style.cursor = "pointer";
      row.style.transition = "background-color 0.15s ease";
      const checkboxCell = row.insertCell();
      checkboxCell.style.padding = "10px 12px";
      checkboxCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      checkboxCell.style.textAlign = "center";
      checkboxCell.style.width = "70px";
      const cellWrapper = document.createElement("div");
      cellWrapper.style.display = "flex";
      cellWrapper.style.gap = "8px";
      cellWrapper.style.alignItems = "center";
      cellWrapper.style.justifyContent = "center";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = true;
      checkbox.value = note.id;
      checkbox.style.cursor = "pointer";
      checkbox.style.width = "16px";
      checkbox.style.height = "16px";
      checkbox.onchange = () => this.toggleSelection(note.id);
      cellWrapper.appendChild(checkbox);
      const trashIcon = document.createElement("span");
      trashIcon.style.cursor = "pointer";
      trashIcon.style.color = "var(--text-muted)";
      trashIcon.style.opacity = "0.6";
      trashIcon.style.visibility = "hidden";
      trashIcon.style.transition = "opacity 0.15s, color 0.15s";
      trashIcon.setAttribute("data-trash-icon", "true");
      trashIcon.setAttribute("aria-label", "Exclude from future syncs");
      trashIcon.onmouseenter = () => {
        trashIcon.style.opacity = "1";
        trashIcon.style.color = "var(--text-error)";
      };
      trashIcon.onmouseleave = () => {
        trashIcon.style.opacity = "0.6";
        trashIcon.style.color = "var(--text-muted)";
      };
      trashIcon.onclick = (e) => {
        e.stopPropagation();
        this.handleTrash(note.id);
      };
      (0, import_obsidian4.setIcon)(trashIcon, "trash-2");
      cellWrapper.appendChild(trashIcon);
      checkboxCell.appendChild(cellWrapper);
      row.onmouseenter = () => {
        if (this.currentRowIndex !== index) {
          row.style.backgroundColor = "var(--background-secondary)";
        }
        const icon = row.querySelector('[data-trash-icon="true"]');
        if (icon)
          icon.style.visibility = "visible";
      };
      row.onmouseleave = () => {
        if (this.currentRowIndex !== index) {
          row.style.backgroundColor = "";
        }
        if (this.currentRowIndex !== index) {
          const icon = row.querySelector('[data-trash-icon="true"]');
          if (icon)
            icon.style.visibility = "hidden";
        }
      };
      row.onclick = (e) => {
        const target = e.target;
        if (target !== checkbox && !trashIcon.contains(target)) {
          this.setCurrentRow(index);
          checkbox.checked = !checkbox.checked;
          this.toggleSelection(note.id);
        } else {
          this.setCurrentRow(index);
        }
      };
      const nameCell = row.insertCell();
      nameCell.textContent = note.name;
      nameCell.style.padding = "10px 12px";
      nameCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      nameCell.style.fontWeight = "500";
      const pathCell = row.insertCell();
      pathCell.textContent = this.truncatePath(note.path);
      pathCell.title = note.path;
      pathCell.style.padding = "10px 12px";
      pathCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      pathCell.style.color = "var(--text-muted)";
      pathCell.style.fontSize = "0.9em";
      const dateCell = row.insertCell();
      dateCell.textContent = this.formatDate(note.modifiedAt);
      dateCell.style.padding = "10px 12px";
      dateCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      const pagesCell = row.insertCell();
      pagesCell.textContent = ((_a = note.pageCount) == null ? void 0 : _a.toString()) || "-";
      pagesCell.style.padding = "10px 12px";
      pagesCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      pagesCell.style.textAlign = "center";
      const sizeCell = row.insertCell();
      sizeCell.textContent = formatFileSize(note.size);
      sizeCell.style.padding = "10px 12px";
      sizeCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      sizeCell.style.textAlign = "right";
      if (showStatusColumn) {
        const statusCell = row.insertCell();
        const localFile = this.localNotes.get(note.id);
        const isModified = localFile && localFile.mtime && this.lastSync && localFile.mtime > this.lastSync;
        if (isModified) {
          statusCell.textContent = "Modified";
          statusCell.style.color = "var(--text-warning)";
          statusCell.style.fontWeight = "600";
        } else {
          statusCell.textContent = "Unmodified";
          statusCell.style.color = "var(--text-muted)";
        }
        statusCell.style.padding = "10px 12px";
        statusCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      }
    });
    if (this.tableRows.length > 0) {
      this.setCurrentRow(0);
    }
    return table;
  }
  registerKeyboardHandlers() {
    this.scope.register([], "ArrowDown", (evt) => {
      evt.preventDefault();
      if (this.currentRowIndex < this.tableRows.length - 1) {
        this.setCurrentRow(this.currentRowIndex + 1);
      }
      return false;
    });
    this.scope.register([], "ArrowUp", (evt) => {
      evt.preventDefault();
      if (this.currentRowIndex > 0) {
        this.setCurrentRow(this.currentRowIndex - 1);
      }
      return false;
    });
    this.scope.register([], " ", (evt) => {
      evt.preventDefault();
      this.toggleCurrentRow();
      return false;
    });
    this.scope.register([], "Enter", (evt) => {
      evt.preventDefault();
      this.toggleCurrentRow();
      return false;
    });
  }
  setCurrentRow(index) {
    if (this.tableRows[this.currentRowIndex]) {
      this.tableRows[this.currentRowIndex].style.backgroundColor = "";
      const prevIcon = this.tableRows[this.currentRowIndex].querySelector('[data-trash-icon="true"]');
      if (prevIcon)
        prevIcon.style.visibility = "hidden";
    }
    this.currentRowIndex = index;
    if (this.tableRows[this.currentRowIndex]) {
      this.tableRows[this.currentRowIndex].style.backgroundColor = "var(--background-modifier-hover)";
      this.tableRows[this.currentRowIndex].scrollIntoView({ block: "nearest", behavior: "smooth" });
      const currentIcon = this.tableRows[this.currentRowIndex].querySelector('[data-trash-icon="true"]');
      if (currentIcon)
        currentIcon.style.visibility = "visible";
    }
  }
  toggleCurrentRow() {
    if (this.tableRows[this.currentRowIndex]) {
      const checkbox = this.tableRows[this.currentRowIndex].querySelector('input[type="checkbox"]');
      if (checkbox) {
        checkbox.checked = !checkbox.checked;
        this.toggleSelection(checkbox.value);
      }
    }
  }
  toggleSelection(noteId) {
    if (this.selectedNotes.has(noteId)) {
      this.selectedNotes.delete(noteId);
    } else {
      this.selectedNotes.add(noteId);
    }
    this.updateButtonStates();
  }
  selectAll() {
    this.selectedNotes = new Set(this.notes.map((n) => n.id));
    const checkboxes = this.containerEl.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach((cb) => {
      cb.checked = true;
    });
    this.updateButtonStates();
  }
  deselectAll() {
    this.selectedNotes.clear();
    const checkboxes = this.containerEl.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach((cb) => {
      cb.checked = false;
    });
    this.updateButtonStates();
  }
  updateButtonStates() {
    const selectedCount = this.selectedNotes.size;
    const totalCount = this.notes.length;
    if (this.confirmButton) {
      this.confirmButton.textContent = `Confirm (${selectedCount} selected)`;
      this.confirmButton.disabled = selectedCount === 0;
    }
    if (this.selectAllBtn) {
      this.selectAllBtn.disabled = selectedCount === totalCount;
    }
    if (this.deselectAllBtn) {
      this.deselectAllBtn.disabled = selectedCount === 0;
    }
    if (this.trashAllBtn) {
      this.trashAllBtn.disabled = selectedCount === 0;
    }
  }
  handleTrash(noteId) {
    this.onTrash(noteId);
    this.selectedNotes.delete(noteId);
    this.notes = this.notes.filter((n) => n.id !== noteId);
    const rowIndex = this.tableRows.findIndex((row) => {
      const checkbox = row.querySelector('input[type="checkbox"]');
      return checkbox && checkbox.value === noteId;
    });
    if (rowIndex !== -1) {
      this.tableRows[rowIndex].remove();
      this.tableRows.splice(rowIndex, 1);
      if (this.currentRowIndex >= this.tableRows.length) {
        this.currentRowIndex = Math.max(0, this.tableRows.length - 1);
      }
      if (this.tableRows.length > 0) {
        this.setCurrentRow(this.currentRowIndex);
      }
    }
    this.updateButtonStates();
    if (this.notes.length === 0) {
      this.close();
    }
  }
  handleTrashAllSelected() {
    const selectedIds = Array.from(this.selectedNotes);
    if (selectedIds.length === 0) {
      new import_obsidian4.Notice("No notes selected");
      return;
    }
    const confirmModal = new import_obsidian4.Modal(this.app);
    confirmModal.titleEl.setText("Confirm Trash Selected");
    const { contentEl } = confirmModal;
    contentEl.empty();
    contentEl.createEl("p", {
      text: `Are you sure you want to trash ${selectedIds.length} selected note(s)?`
    });
    contentEl.createEl("p", {
      text: "They will be permanently excluded from all future syncs.",
      cls: "setting-item-description"
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.marginTop = "20px";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => confirmModal.close();
    const confirmBtn = buttonContainer.createEl("button", {
      text: "Trash All",
      cls: "mod-warning"
    });
    confirmBtn.onclick = () => {
      selectedIds.forEach((id) => this.onTrash(id));
      this.notes = this.notes.filter((n) => !selectedIds.includes(n.id));
      this.selectedNotes.clear();
      const tableContainer = this.contentEl.querySelector(".confirmation-table-container");
      if (tableContainer) {
        tableContainer.empty();
        if (this.notes.length > 0) {
          tableContainer.appendChild(this.createNotesTable());
        }
      }
      this.updateButtonStates();
      confirmModal.close();
      new import_obsidian4.Notice(`Trashed ${selectedIds.length} note(s)`);
      if (this.notes.length === 0) {
        this.close();
      }
    };
    confirmModal.open();
  }
  getActionTitle() {
    switch (this.actionType) {
      case "import":
        return "Import New Notes";
      case "update":
        return "Update Existing Notes";
      case "export":
        return "Bulk Export All Notes";
      default:
        return "Confirm Action";
    }
  }
  getActionDescription() {
    switch (this.actionType) {
      case "import":
        return `${this.notes.length} new note(s) found. Select which ones to import:`;
      case "update":
        return `${this.notes.length} note(s) can be updated. Select which ones to update:`;
      case "export":
        return `${this.notes.length} note(s) will be exported. Existing files will be overwritten.`;
      default:
        return `${this.notes.length} note(s) will be affected:`;
    }
  }
  formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric"
    });
  }
  truncatePath(path3, maxLength = 35) {
    if (path3.length <= maxLength)
      return path3;
    const start = path3.slice(0, 12);
    const end = path3.slice(-18);
    return `${start}...${end}`;
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/update-config-modal.ts
var import_obsidian5 = require("obsidian");
var UpdateConfigModal = class extends import_obsidian5.Modal {
  constructor(app, defaultMode, defaultFields, defaultTagsStrategy, defaultPreserveCustomFields, exportOptions, onConfirm, onCancel) {
    super(app);
    this.fieldsContainer = null;
    this.updateMode = defaultMode;
    this.specificFields = new Set(defaultFields);
    this.tagsMergeStrategy = defaultTagsStrategy;
    this.preserveCustomFields = defaultPreserveCustomFields;
    this.exportOptions = exportOptions;
    this.onConfirm = onConfirm;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "550px";
    this.modalEl.style.maxWidth = "90%";
    this.titleEl.setText("Configure Update Options");
    contentEl.createEl("p", {
      text: "Choose what to update in the selected notes. These settings override your defaults for this update only.",
      cls: "setting-item-description"
    }).style.marginBottom = "20px";
    new import_obsidian5.Setting(contentEl).setName("Update mode").setDesc("Choose what to update").addDropdown(
      (dropdown) => dropdown.addOption("all", "Update everything").addOption("frontmatter-only", "Update frontmatter only").addOption("content-only", "Update content only").addOption("specific-frontmatter", "Update specific frontmatter fields").setValue(this.updateMode).onChange((value) => {
        this.updateMode = value;
        this.refreshFieldsSection();
      })
    );
    this.fieldsContainer = contentEl.createDiv("update-specific-fields");
    this.refreshFieldsSection();
    new import_obsidian5.Setting(contentEl).setName("Preserve custom fields").setDesc("Keep user-added frontmatter fields that are not part of standard Supernote data").addToggle(
      (toggle) => toggle.setValue(this.preserveCustomFields).onChange((value) => {
        this.preserveCustomFields = value;
      })
    );
    contentEl.createEl("h4", { text: "Array Merge Strategies" }).style.marginTop = "20px";
    new import_obsidian5.Setting(contentEl).setName("Tags").setDesc("How to handle tags when updating").addDropdown(
      (dropdown) => dropdown.addOption("replace", "Replace (overwrite all)").addOption("merge", "Merge (combine existing + new)").setValue(this.tagsMergeStrategy).onChange((value) => {
        this.tagsMergeStrategy = value;
      })
    );
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.marginTop = "25px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => {
      this.close();
      this.onCancel();
    };
    const continueButton = buttonContainer.createEl("button", {
      text: "Continue",
      cls: "mod-cta"
    });
    continueButton.onclick = () => {
      const options = {
        mode: this.updateMode,
        specificFields: this.updateMode === "specific-frontmatter" ? Array.from(this.specificFields) : void 0,
        preserveCustomFields: this.preserveCustomFields,
        arrayMergeStrategy: {
          tags: this.tagsMergeStrategy
        },
        exportOptions: this.exportOptions
      };
      this.close();
      this.onConfirm(options);
    };
  }
  refreshFieldsSection() {
    if (!this.fieldsContainer)
      return;
    this.fieldsContainer.empty();
    if (this.updateMode === "specific-frontmatter") {
      this.fieldsContainer.style.display = "block";
      this.fieldsContainer.style.marginLeft = "20px";
      this.fieldsContainer.style.padding = "15px";
      this.fieldsContainer.style.backgroundColor = "var(--background-secondary)";
      this.fieldsContainer.style.borderRadius = "8px";
      this.fieldsContainer.style.marginBottom = "15px";
      this.fieldsContainer.createEl("div", {
        text: "Select which frontmatter fields to update:",
        cls: "setting-item-description"
      }).style.marginBottom = "10px";
      const fieldOptions = [
        { key: "name", label: "Name", desc: "Note title" },
        { key: "source", label: "Source", desc: "Original Supernote path" },
        { key: "date", label: "Date", desc: "Creation/modification dates" },
        { key: "pageCount", label: "Page Count", desc: "Number of pages" },
        { key: "size", label: "Size", desc: "File size" },
        { key: "tags", label: "Tags", desc: "Note tags" }
      ];
      fieldOptions.forEach((field) => {
        new import_obsidian5.Setting(this.fieldsContainer).setName(field.label).setDesc(field.desc).addToggle(
          (toggle) => toggle.setValue(this.specificFields.has(field.key)).onChange((value) => {
            if (value) {
              this.specificFields.add(field.key);
            } else {
              this.specificFields.delete(field.key);
            }
          })
        );
      });
    } else {
      this.fieldsContainer.style.display = "none";
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/update-preview-modal.ts
var import_obsidian6 = require("obsidian");
var UpdatePreviewModal = class extends import_obsidian6.Modal {
  constructor(app, notePreviews, updateOptions, onContinue, onCancel) {
    super(app);
    this.notePreviews = notePreviews;
    this.updateOptions = updateOptions;
    this.onContinue = onContinue;
    this.onCancel = onCancel;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "90%";
    this.modalEl.style.maxWidth = "1200px";
    this.titleEl.setText("Update Preview");
    const summaryEl = contentEl.createDiv("update-preview-summary");
    summaryEl.style.marginBottom = "20px";
    summaryEl.style.padding = "15px";
    summaryEl.style.backgroundColor = "var(--background-secondary)";
    summaryEl.style.borderRadius = "8px";
    const modeEl = summaryEl.createEl("h4", {
      text: `Update Mode: ${this.getUpdateModeLabel()}`
    });
    modeEl.style.margin = "0 0 10px 0";
    const details = [];
    if (this.updateOptions.mode === "specific-frontmatter" && this.updateOptions.specificFields) {
      details.push(`Fields: ${this.updateOptions.specificFields.join(", ")}`);
    }
    if (this.updateOptions.preserveCustomFields) {
      details.push("Custom fields will be preserved");
    }
    details.push(`Tags: ${this.updateOptions.arrayMergeStrategy.tags === "merge" ? "Merge" : "Replace"}`);
    summaryEl.createEl("div", {
      text: details.join(" \u2022 "),
      cls: "setting-item-description"
    });
    const filesWithChanges = this.notePreviews.filter((p) => p.preview.hasChanges).length;
    const totalFiles = this.notePreviews.length;
    const statsEl = contentEl.createDiv("update-preview-stats");
    statsEl.style.marginBottom = "15px";
    statsEl.innerHTML = `
            <strong style="color: var(--text-accent);">
                ${filesWithChanges} of ${totalFiles} file(s) will be updated
            </strong>
        `;
    const tableContainer = contentEl.createDiv("update-preview-table-container");
    tableContainer.style.maxHeight = "450px";
    tableContainer.style.overflowY = "auto";
    tableContainer.style.marginBottom = "20px";
    tableContainer.style.border = "1px solid var(--background-modifier-border)";
    tableContainer.style.borderRadius = "6px";
    tableContainer.appendChild(this.createPreviewTable());
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.onclick = () => {
      this.close();
      this.onCancel();
    };
    const continueButton = buttonContainer.createEl("button", {
      text: "Continue to Selection",
      cls: "mod-cta"
    });
    continueButton.onclick = () => {
      this.close();
      this.onContinue();
    };
  }
  createPreviewTable() {
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    const headers = ["File", "Frontmatter Changes", "Content", "Custom Fields"];
    headers.forEach((headerText) => {
      const th = document.createElement("th");
      th.textContent = headerText;
      th.style.textAlign = "left";
      th.style.padding = "12px";
      th.style.borderBottom = "2px solid var(--background-modifier-border)";
      th.style.fontWeight = "600";
      th.style.fontSize = "0.85em";
      th.style.textTransform = "uppercase";
      th.style.letterSpacing = "0.5px";
      th.style.color = "var(--text-muted)";
      th.style.position = "sticky";
      th.style.top = "0";
      th.style.backgroundColor = "var(--background-primary)";
      th.style.zIndex = "10";
      headerRow.appendChild(th);
    });
    const tbody = table.createTBody();
    this.notePreviews.forEach((preview, index) => {
      const row = tbody.insertRow();
      row.style.backgroundColor = index % 2 === 0 ? "transparent" : "var(--background-secondary-alt)";
      const fileCell = row.insertCell();
      fileCell.style.padding = "12px";
      fileCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      fileCell.style.maxWidth = "300px";
      fileCell.style.overflow = "hidden";
      fileCell.style.textOverflow = "ellipsis";
      fileCell.style.whiteSpace = "nowrap";
      fileCell.textContent = preview.note.name;
      fileCell.title = preview.note.name;
      const fmCell = row.insertCell();
      fmCell.style.padding = "12px";
      fmCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      if (preview.preview.frontmatterChanges.length > 0) {
        const changesList = document.createElement("div");
        changesList.style.fontSize = "0.9em";
        const fields = preview.preview.frontmatterChanges.map((c) => c.field);
        const fieldsText = fields.length <= 3 ? fields.join(", ") : `${fields.slice(0, 3).join(", ")} +${fields.length - 3} more`;
        changesList.innerHTML = `<span style="color: var(--text-accent);">${fieldsText}</span>`;
        changesList.title = fields.join(", ");
        fmCell.appendChild(changesList);
      } else {
        fmCell.textContent = "-";
        fmCell.style.color = "var(--text-muted)";
      }
      const contentCell = row.insertCell();
      contentCell.style.padding = "12px";
      contentCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      if (preview.preview.contentChanged) {
        contentCell.innerHTML = '<span style="color: var(--color-orange);">Will update</span>';
      } else {
        contentCell.textContent = "No change";
        contentCell.style.color = "var(--text-muted)";
      }
      const customCell = row.insertCell();
      customCell.style.padding = "12px";
      customCell.style.borderBottom = "1px solid var(--background-modifier-border)";
      if (preview.preview.customFieldsPreserved.length > 0) {
        const preserved = preview.preview.customFieldsPreserved;
        const text = preserved.length <= 2 ? preserved.join(", ") : `${preserved.slice(0, 2).join(", ")} +${preserved.length - 2}`;
        customCell.innerHTML = `<span style="color: var(--color-green);">${text}</span>`;
        customCell.title = preserved.join(", ");
      } else {
        customCell.textContent = "-";
        customCell.style.color = "var(--text-muted)";
      }
    });
    return table;
  }
  getUpdateModeLabel() {
    switch (this.updateOptions.mode) {
      case "all":
        return "Update Everything";
      case "frontmatter-only":
        return "Frontmatter Only";
      case "content-only":
        return "Content Only";
      case "specific-frontmatter":
        return "Specific Frontmatter Fields";
      default:
        return "Unknown";
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/trash-modal.ts
var import_obsidian7 = require("obsidian");
var TrashManagementModal = class extends import_obsidian7.Modal {
  constructor(app, trashedIds, trashedNotes, onRestore, onRestoreAll) {
    super(app);
    this.trashedIds = trashedIds;
    this.trashedNotes = trashedNotes;
    this.onRestore = onRestore;
    this.onRestoreAll = onRestoreAll;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.modalEl.style.width = "700px";
    this.modalEl.style.maxWidth = "90%";
    this.titleEl.setText("Manage Trashed Notes");
    contentEl.createEl("p", {
      text: "These notes have been excluded from sync. Restore them to include them in future syncs.",
      cls: "setting-item-description"
    }).style.marginBottom = "15px";
    const countEl = contentEl.createEl("p");
    countEl.innerHTML = `<strong>${this.trashedIds.length}</strong> note(s) currently trashed`;
    countEl.style.marginBottom = "20px";
    if (this.trashedIds.length === 0) {
      const emptyEl = contentEl.createDiv("trash-empty");
      emptyEl.style.textAlign = "center";
      emptyEl.style.padding = "40px";
      emptyEl.style.color = "var(--text-muted)";
      emptyEl.innerHTML = `
                <div style="font-size: 3em; margin-bottom: 10px;">\u{1F5D1}\uFE0F</div>
                <div>No notes in trash</div>
            `;
    } else {
      const listContainer = contentEl.createDiv("trash-list-container");
      listContainer.style.maxHeight = "400px";
      listContainer.style.overflowY = "auto";
      listContainer.style.border = "1px solid var(--background-modifier-border)";
      listContainer.style.borderRadius = "6px";
      this.createTrashList(listContainer);
      const restoreAllContainer = contentEl.createDiv();
      restoreAllContainer.style.marginTop = "15px";
      restoreAllContainer.style.textAlign = "right";
      const restoreAllBtn = restoreAllContainer.createEl("button", {
        text: "Restore All",
        cls: "mod-cta"
      });
      restoreAllBtn.onclick = () => {
        this.onRestoreAll();
        new import_obsidian7.Notice(`Restored ${this.trashedIds.length} note(s)`);
        this.close();
      };
    }
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    buttonContainer.style.marginTop = "20px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    const closeButton = buttonContainer.createEl("button", { text: "Close" });
    closeButton.onclick = () => this.close();
  }
  createTrashList(container) {
    const list = container.createDiv("trash-list");
    if (this.trashedNotes.length > 0) {
      this.trashedNotes.forEach((note) => {
        this.createNoteItem(list, note);
      });
    } else {
      this.trashedIds.forEach((id) => {
        this.createIdItem(list, id);
      });
    }
  }
  createNoteItem(container, note) {
    const item = container.createDiv("trash-item");
    item.style.display = "flex";
    item.style.alignItems = "center";
    item.style.justifyContent = "space-between";
    item.style.padding = "12px 15px";
    item.style.borderBottom = "1px solid var(--background-modifier-border)";
    const infoDiv = item.createDiv("trash-item-info");
    infoDiv.style.flex = "1";
    infoDiv.style.minWidth = "0";
    const nameEl = infoDiv.createEl("div", { text: note.name });
    nameEl.style.fontWeight = "500";
    nameEl.style.marginBottom = "4px";
    nameEl.style.overflow = "hidden";
    nameEl.style.textOverflow = "ellipsis";
    nameEl.style.whiteSpace = "nowrap";
    const pathEl = infoDiv.createEl("div", { text: note.path });
    pathEl.style.fontSize = "0.85em";
    pathEl.style.color = "var(--text-muted)";
    pathEl.style.overflow = "hidden";
    pathEl.style.textOverflow = "ellipsis";
    pathEl.style.whiteSpace = "nowrap";
    const restoreBtn = item.createEl("button", { text: "Restore" });
    restoreBtn.style.marginLeft = "15px";
    restoreBtn.onclick = () => {
      this.onRestore(note.id);
      item.remove();
      new import_obsidian7.Notice(`Restored: ${note.name}`);
      this.trashedIds = this.trashedIds.filter((id) => id !== note.id);
      if (this.trashedIds.length === 0) {
        this.close();
        new import_obsidian7.Notice("All notes restored");
      }
    };
  }
  createIdItem(container, id) {
    const item = container.createDiv("trash-item");
    item.style.display = "flex";
    item.style.alignItems = "center";
    item.style.justifyContent = "space-between";
    item.style.padding = "12px 15px";
    item.style.borderBottom = "1px solid var(--background-modifier-border)";
    const infoDiv = item.createDiv("trash-item-info");
    infoDiv.style.flex = "1";
    infoDiv.style.minWidth = "0";
    const idEl = infoDiv.createEl("div", { text: `ID: ${this.truncateId(id)}` });
    idEl.style.fontFamily = "var(--font-monospace)";
    idEl.style.fontSize = "0.9em";
    idEl.title = id;
    const restoreBtn = item.createEl("button", { text: "Restore" });
    restoreBtn.style.marginLeft = "15px";
    restoreBtn.onclick = () => {
      this.onRestore(id);
      item.remove();
      new import_obsidian7.Notice(`Restored note ID: ${this.truncateId(id)}`);
      this.trashedIds = this.trashedIds.filter((i) => i !== id);
      if (this.trashedIds.length === 0) {
        this.close();
        new import_obsidian7.Notice("All notes restored");
      }
    };
  }
  truncateId(id, maxLength = 20) {
    if (id.length <= maxLength)
      return id;
    return `${id.slice(0, 8)}...${id.slice(-8)}`;
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/sync/matcher.ts
var import_obsidian8 = require("obsidian");
async function scanLocalNotes(vault, folderPath) {
  const localNotes = /* @__PURE__ */ new Map();
  const normalizedFolder = folderPath.startsWith("/") ? folderPath.slice(1) : folderPath;
  const mdFiles = vault.getMarkdownFiles().filter(
    (file) => file.path.startsWith(normalizedFolder)
  );
  for (const file of mdFiles) {
    try {
      const content = await vault.read(file);
      const frontmatter = parseFrontmatter(content);
      if (frontmatter.source && frontmatter.supernote_id) {
        const id = String(frontmatter.supernote_id);
        localNotes.set(id, {
          path: file.path,
          id,
          sourcePath: String(frontmatter.source),
          mtime: file.stat.mtime,
          pdfPath: frontmatter.pdf_attachment ? String(frontmatter.pdf_attachment) : void 0
        });
      }
    } catch (error) {
      console.error(`Failed to process markdown file ${file.path}:`, error);
    }
  }
  const allFiles = vault.getFiles().filter(
    (file) => file.path.startsWith(normalizedFolder) && file.extension === "pdf"
  );
  for (const file of allFiles) {
    const basename = file.basename;
    const pdfId = `pdf:${basename}`;
    if (!localNotes.has(pdfId)) {
      localNotes.set(pdfId, {
        path: file.path,
        id: pdfId,
        sourcePath: "",
        // Unknown for standalone PDFs
        mtime: file.stat.mtime,
        pdfPath: file.path
      });
    }
  }
  return localNotes;
}
async function scanLocalPdfsByName(vault, folderPath) {
  const pdfsByName = /* @__PURE__ */ new Map();
  const normalizedFolder = folderPath.startsWith("/") ? folderPath.slice(1) : folderPath;
  const allFiles = vault.getFiles().filter(
    (file) => file.path.startsWith(normalizedFolder) && file.extension === "pdf"
  );
  for (const file of allFiles) {
    const normalizedName = file.basename.toLowerCase().replace(/\+/g, " ");
    pdfsByName.set(normalizedName, file);
    pdfsByName.set(file.basename.toLowerCase(), file);
  }
  return pdfsByName;
}
function parseFrontmatter(content) {
  const match = content.match(/^---\n([\s\S]*?)\n---/);
  if (!match)
    return {};
  const yaml = match[1];
  const frontmatter = {};
  const lines = yaml.split("\n");
  let currentKey = "";
  let isArray = false;
  let arrayValues = [];
  for (const line of lines) {
    if (line.match(/^\s+-\s+/)) {
      if (isArray && currentKey) {
        const value2 = line.replace(/^\s+-\s+/, "").trim();
        const unquoted = value2.replace(/^["']|["']$/g, "");
        const cleaned = unquoted.replace(/^\[\[|\]\]$/g, "");
        arrayValues.push(cleaned);
      }
      continue;
    }
    if (isArray && currentKey) {
      frontmatter[currentKey] = arrayValues;
      isArray = false;
      arrayValues = [];
    }
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1)
      continue;
    const key = line.slice(0, colonIndex).trim();
    const value = line.slice(colonIndex + 1).trim();
    if (!key)
      continue;
    currentKey = key;
    if (value === "" || value === "|" || value === ">") {
      isArray = true;
      arrayValues = [];
    } else if (value.startsWith("[") && value.endsWith("]")) {
      const items = value.slice(1, -1).split(",").map((s) => s.trim().replace(/^["']|["']$/g, ""));
      frontmatter[key] = items;
    } else {
      frontmatter[key] = value.replace(/^["']|["']$/g, "");
    }
  }
  if (isArray && currentKey) {
    frontmatter[currentKey] = arrayValues;
  }
  return frontmatter;
}

// src/sync/status.ts
function calculateSyncStatus(remoteNotes, localNotes, existingPdfNames) {
  const status = {
    new: [],
    updated: [],
    synced: []
  };
  remoteNotes.forEach((note) => {
    const localFile = localNotes.get(note.id);
    const normalizedName = note.name.toLowerCase().replace(/\+/g, " ");
    const existingPdf = (existingPdfNames == null ? void 0 : existingPdfNames.get(normalizedName)) || (existingPdfNames == null ? void 0 : existingPdfNames.get(note.name.toLowerCase()));
    if (!localFile && !existingPdf) {
      status.new.push(note);
    } else if (localFile) {
      const remoteModified = new Date(note.modifiedAt).getTime();
      const localModified = localFile.mtime;
      if (remoteModified > localModified) {
        status.updated.push(note);
      } else {
        status.synced.push(note);
      }
    } else if (existingPdf) {
      const remoteModified = new Date(note.modifiedAt).getTime();
      const localModified = existingPdf.stat.mtime;
      if (remoteModified > localModified) {
        status.updated.push(note);
      } else {
        status.synced.push(note);
      }
    }
  });
  return status;
}
function filterNewNotes(remoteNotes, localNotes, existingPdfNames) {
  return remoteNotes.filter((note) => {
    if (localNotes.has(note.id)) {
      return false;
    }
    if (existingPdfNames) {
      const normalizedName = note.name.toLowerCase().replace(/\+/g, " ");
      if (existingPdfNames.has(normalizedName) || existingPdfNames.has(note.name.toLowerCase())) {
        return false;
      }
    }
    return true;
  });
}
function filterExistingNotes(remoteNotes, localNotes) {
  return remoteNotes.filter((note) => localNotes.has(note.id));
}
function splitByModificationStatus(notes, localNotes, lastSync) {
  const modified = [];
  const unmodified = [];
  for (const note of notes) {
    const localFile = localNotes.get(note.id);
    if (localFile && localFile.mtime > lastSync) {
      modified.push(note);
    } else {
      unmodified.push(note);
    }
  }
  return { modified, unmodified };
}
function deduplicateNotes(notes) {
  const seenIds = /* @__PURE__ */ new Set();
  return notes.filter((note) => {
    if (seenIds.has(note.id))
      return false;
    seenIds.add(note.id);
    return true;
  });
}

// src/utils/filters.ts
function filterNotes(notes, trashedNoteIds, additionalFilters) {
  let filtered = notes;
  filtered = filtered.filter((note) => !trashedNoteIds.includes(note.id));
  if (additionalFilters) {
    if (additionalFilters.excludePatterns) {
      filtered = filtered.filter(
        (note) => !additionalFilters.excludePatterns.some((pattern) => pattern.test(note.name))
      );
    }
    if (additionalFilters.includePatterns && additionalFilters.includePatterns.length > 0) {
      filtered = filtered.filter(
        (note) => additionalFilters.includePatterns.some((pattern) => pattern.test(note.name))
      );
    }
    if (additionalFilters.minSize !== void 0) {
      filtered = filtered.filter((note) => note.size >= additionalFilters.minSize);
    }
    if (additionalFilters.maxSize !== void 0) {
      filtered = filtered.filter((note) => note.size <= additionalFilters.maxSize);
    }
    if (additionalFilters.afterDate) {
      filtered = filtered.filter(
        (note) => new Date(note.modifiedAt) >= additionalFilters.afterDate
      );
    }
    if (additionalFilters.beforeDate) {
      filtered = filtered.filter(
        (note) => new Date(note.modifiedAt) <= additionalFilters.beforeDate
      );
    }
  }
  return filtered;
}
function sortNotes(notes, sortBy = "date", ascending = true) {
  const sorted = [...notes].sort((a, b) => {
    let comparison = 0;
    switch (sortBy) {
      case "name":
        comparison = a.name.localeCompare(b.name);
        break;
      case "date":
        comparison = new Date(a.modifiedAt).getTime() - new Date(b.modifiedAt).getTime();
        break;
      case "size":
        comparison = a.size - b.size;
        break;
      case "path":
        comparison = a.path.localeCompare(b.path);
        break;
    }
    return ascending ? comparison : -comparison;
  });
  return sorted;
}

// src/sync/importer.ts
var import_obsidian9 = require("obsidian");
var fs2 = require("fs");
var path2 = require("path");
var MAX_CONCURRENT_DOWNLOADS = 6;
async function parallelLimit(items, limit, fn) {
  const results = new Array(items.length);
  let currentIndex = 0;
  async function worker() {
    while (currentIndex < items.length) {
      const index = currentIndex++;
      results[index] = await fn(items[index], index);
    }
  }
  const workers = Array(Math.min(limit, items.length)).fill(null).map(() => worker());
  await Promise.all(workers);
  return results;
}
var NoteImporter = class {
  constructor(vault, client, notesFolder, pdfFolder, importMode, filenameTemplate, preserveFolderStructure, exportOptions, converterMode = "cli", converterPath = "") {
    this.vault = vault;
    this.client = client;
    this.pdfConverter = new PdfConverter(converterMode, converterPath);
    this.notesFolder = notesFolder;
    this.pdfFolder = pdfFolder;
    this.importMode = importMode;
    this.filenameTemplate = filenameTemplate;
    this.preserveFolderStructure = preserveFolderStructure;
    this.exportOptions = exportOptions;
  }
  /**
   * Check if the PDF conversion is available (always true with built-in converter)
   */
  async isPdfToolAvailable() {
    return this.pdfConverter.isToolAvailable();
  }
  /**
   * Get the version of the PDF converter
   */
  async getPdfToolVersion() {
    return this.pdfConverter.getToolVersion();
  }
  /**
   * Set update options for selective updates
   */
  setUpdateOptions(options) {
    this.updateOptions = options;
  }
  /**
   * Import multiple notes with progress tracking.
   * Uses batch mode for pdf-only imports with CLI converter (much faster).
   * Falls back to single-file mode for other import modes or built-in converter.
   */
  async importNotesWithProgress(notes, onProgress) {
    if (this.importMode === "pdf-only" && this.pdfConverter.canBatchConvert()) {
      return this.importNotesWithProgressBatch(notes, onProgress);
    }
    return this.importNotesWithProgressSingle(notes, onProgress);
  }
  /**
   * Import notes one at a time (legacy mode, used for markdown modes or built-in converter)
   */
  async importNotesWithProgressSingle(notes, onProgress) {
    let successCount = 0;
    let failureCount = 0;
    const total = notes.length;
    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      onProgress(i + 1, total, successCount, failureCount, note.name);
      try {
        await this.importSingleNote(note);
        successCount++;
      } catch (error) {
        console.error(`Failed to import ${note.name}:`, error);
        failureCount++;
      }
    }
    return successCount;
  }
  /**
   * Import notes using batch mode (CLI only, pdf-only mode).
   * 
   * Flow:
   * 1. Download all .note files in parallel to a temp directory
   * 2. Run CLI converter once on the entire directory
   * 3. Copy all PDFs to the vault
   * 4. Clean up temp directories
   */
  async importNotesWithProgressBatch(notes, onProgress) {
    const total = notes.length;
    let successCount = 0;
    let failureCount = 0;
    if (total === 0)
      return 0;
    console.log(`[importer] Starting batch import of ${total} notes (${MAX_CONCURRENT_DOWNLOADS} concurrent downloads)`);
    const inputTempDir = this.pdfConverter.createTempDir("supernote_batch_input", true);
    const outputTempDir = this.pdfConverter.createTempDir("supernote_batch_output", false);
    try {
      onProgress(0, total, 0, 0, `Downloading ${total} notes...`);
      console.log(`[importer] Phase 1: Downloading ${total} notes in parallel to ${inputTempDir}`);
      const downloadStartTime = Date.now();
      let downloadedCount = 0;
      const downloadResults = await parallelLimit(notes, MAX_CONCURRENT_DOWNLOADS, async (note, _index) => {
        try {
          const noteData = await this.client.downloadNoteFile(note.path);
          const relativePath = this.getRelativeNotePath(note);
          await this.pdfConverter.writeNoteToTempDir(inputTempDir, relativePath, noteData);
          downloadedCount++;
          onProgress(downloadedCount, total, 0, 0, `Downloaded ${downloadedCount}/${total}: ${note.name}`);
          console.log(`[importer] Downloaded (${downloadedCount}/${total}): ${relativePath}`);
          return { note, relativePath };
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          console.error(`[importer] Failed to download ${note.name}:`, error);
          return { note, error: errorMsg };
        }
      });
      const downloadTimeMs = Date.now() - downloadStartTime;
      const downloadedNotes = [];
      for (const result of downloadResults) {
        if ("relativePath" in result) {
          downloadedNotes.push(result);
        } else {
          failureCount++;
        }
      }
      console.log(`[importer] Downloaded ${downloadedNotes.length}/${total} notes in ${downloadTimeMs}ms (${Math.round(downloadTimeMs / total)}ms avg per file)`);
      if (downloadedNotes.length === 0) {
        console.error("[importer] No notes downloaded successfully");
        return 0;
      }
      onProgress(downloadedNotes.length, total, 0, failureCount, "Converting to PDF...");
      console.log(`[importer] Phase 2: Converting ${downloadedNotes.length} notes`);
      const conversionResult = await this.pdfConverter.convertDirectory(inputTempDir, outputTempDir);
      if (!conversionResult.success) {
        console.error(`[importer] Batch conversion failed: ${conversionResult.error}`);
        console.log("[importer] Falling back to single-file mode");
        return this.importNotesWithProgressSingle(notes, onProgress);
      }
      console.log(`[importer] Conversion complete: ${conversionResult.fileCount} PDFs in ${conversionResult.conversionTimeMs}ms`);
      onProgress(downloadedNotes.length, total, 0, failureCount, "Importing to vault...");
      console.log(`[importer] Phase 3: Copying PDFs to vault`);
      for (let i = 0; i < downloadedNotes.length; i++) {
        const { note, relativePath } = downloadedNotes[i];
        onProgress(i + 1, total, successCount, failureCount, `Importing: ${note.name}`);
        try {
          const pdfRelativePath = relativePath.replace(/\.note$/, ".pdf");
          const pdfTempPath = path2.join(outputTempDir, pdfRelativePath);
          if (!fs2.existsSync(pdfTempPath)) {
            console.error(`[importer] PDF not found: ${pdfTempPath}`);
            failureCount++;
            continue;
          }
          const pdfBuffer = await fs2.promises.readFile(pdfTempPath);
          const pdfData = pdfBuffer.buffer.slice(
            pdfBuffer.byteOffset,
            pdfBuffer.byteOffset + pdfBuffer.byteLength
          );
          const pdfFilename = generatePdfFilename(note, this.filenameTemplate);
          const pdfVaultPath = this.buildVaultPath(this.notesFolder, note, pdfFilename);
          const folderPath = pdfVaultPath.substring(0, pdfVaultPath.lastIndexOf("/"));
          if (folderPath) {
            await this.ensureFolderExists(folderPath);
          }
          const existingPdf = this.vault.getAbstractFileByPath(pdfVaultPath);
          if (existingPdf) {
            await this.vault.modifyBinary(existingPdf, pdfData);
          } else {
            await this.vault.createBinary(pdfVaultPath, pdfData);
          }
          console.log(`[importer] Imported: ${pdfVaultPath}`);
          successCount++;
        } catch (error) {
          console.error(`[importer] Failed to import ${note.name} to vault:`, error);
          failureCount++;
        }
      }
      console.log(`[importer] Batch import complete: ${successCount} succeeded, ${failureCount} failed`);
      return successCount;
    } finally {
      console.log("[importer] Phase 4: Cleaning up temp directories");
      await this.pdfConverter.cleanupTempDir(inputTempDir);
      await this.pdfConverter.cleanupTempDir(outputTempDir);
    }
  }
  /**
   * Get the relative path for a note file (e.g., "Work/Projects/meeting.note")
   */
  getRelativeNotePath(note) {
    const withoutNotePrefix = note.path.replace(/^\/Note\/?/, "");
    if (this.preserveFolderStructure) {
      return withoutNotePrefix;
    }
    const lastSlash = withoutNotePrefix.lastIndexOf("/");
    return lastSlash >= 0 ? withoutNotePrefix.substring(lastSlash + 1) : withoutNotePrefix;
  }
  /**
   * Import a single note based on import mode
   */
  async importSingleNote(note) {
    switch (this.importMode) {
      case "pdf-only":
        return this.importPdfOnly(note);
      case "markdown-with-pdf":
        return this.importMarkdownWithPdf(note);
      case "markdown-only":
        return this.importMarkdownOnly(note);
      default:
        return this.importPdfOnly(note);
    }
  }
  /**
   * Get the relative folder path from a Supernote note path.
   * E.g., "/Note/Work/Projects/meeting.note" -> "Work/Projects"
   * E.g., "/Note/signature.note" -> "" (empty - file is in root)
   */
  getRelativeFolderPath(notePath) {
    const withoutNotePrefix = notePath.replace(/^\/Note\/?/, "");
    const lastSlashIndex = withoutNotePrefix.lastIndexOf("/");
    if (lastSlashIndex === -1) {
      return "";
    }
    return withoutNotePrefix.substring(0, lastSlashIndex);
  }
  /**
   * Build the full vault path for a file, optionally preserving folder structure
   */
  buildVaultPath(baseFolder, note, filename) {
    const normalizedBase = baseFolder.startsWith("/") ? baseFolder.slice(1) : baseFolder;
    if (this.preserveFolderStructure) {
      const relativePath = this.getRelativeFolderPath(note.path);
      if (relativePath) {
        return (0, import_obsidian9.normalizePath)(`${normalizedBase}/${relativePath}/${filename}`);
      }
    }
    return (0, import_obsidian9.normalizePath)(`${normalizedBase}/${filename}`);
  }
  /**
   * Import just the PDF file (simplest mode)
   */
  async importPdfOnly(note) {
    try {
      const noteData = await this.client.downloadNoteFile(note.path);
      const conversionResult = await this.pdfConverter.convert(noteData, note.id);
      if (!conversionResult.success || !conversionResult.pdfData) {
        throw new Error(`PDF conversion failed: ${conversionResult.error || "Unknown error"}`);
      }
      const pdfFilename = generatePdfFilename(note, this.filenameTemplate);
      const pdfVaultPath = this.buildVaultPath(this.notesFolder, note, pdfFilename);
      const folderPath = pdfVaultPath.substring(0, pdfVaultPath.lastIndexOf("/"));
      if (folderPath) {
        await this.ensureFolderExists(folderPath);
      }
      const existingPdf = this.vault.getAbstractFileByPath(pdfVaultPath);
      if (existingPdf) {
        await this.vault.modifyBinary(existingPdf, conversionResult.pdfData);
      } else {
        await this.vault.createBinary(pdfVaultPath, conversionResult.pdfData);
      }
      console.log(`Imported ${note.name} as PDF (${conversionResult.pageCount} pages) in ${conversionResult.conversionTimeMs}ms`);
      return {
        success: true,
        note,
        pdfPath: pdfVaultPath
      };
    } catch (error) {
      return {
        success: false,
        note,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Import markdown file with PDF attachment (original mode)
   */
  async importMarkdownWithPdf(note) {
    try {
      let pdfVaultPath;
      let thumbnailBase64;
      if (this.exportOptions.attachPdf) {
        pdfVaultPath = await this.handlePdfAttachment(note);
      }
      if (this.exportOptions.includeThumbnail) {
        thumbnailBase64 = await this.client.getThumbnail(note.id) || void 0;
      }
      const content = generateMarkdown(note, this.exportOptions, pdfVaultPath, thumbnailBase64);
      const filename = generateFilename(note, this.filenameTemplate);
      const filepath = this.buildVaultPath(this.notesFolder, note, filename);
      const folderPath = filepath.substring(0, filepath.lastIndexOf("/"));
      if (folderPath) {
        await this.ensureFolderExists(folderPath);
      }
      const existingFile = this.vault.getAbstractFileByPath(filepath);
      if (existingFile) {
        await this.vault.modify(existingFile, content);
      } else {
        await this.vault.create(filepath, content);
      }
      return {
        success: true,
        note,
        markdownPath: filepath,
        pdfPath: pdfVaultPath
      };
    } catch (error) {
      return {
        success: false,
        note,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Import just the markdown file without PDF
   */
  async importMarkdownOnly(note) {
    try {
      let thumbnailBase64;
      if (this.exportOptions.includeThumbnail) {
        thumbnailBase64 = await this.client.getThumbnail(note.id) || void 0;
      }
      const optionsWithoutPdf = { ...this.exportOptions, attachPdf: false };
      const content = generateMarkdown(note, optionsWithoutPdf, void 0, thumbnailBase64);
      const filename = generateFilename(note, this.filenameTemplate);
      const filepath = this.buildVaultPath(this.notesFolder, note, filename);
      const folderPath = filepath.substring(0, filepath.lastIndexOf("/"));
      if (folderPath) {
        await this.ensureFolderExists(folderPath);
      }
      const existingFile = this.vault.getAbstractFileByPath(filepath);
      if (existingFile) {
        await this.vault.modify(existingFile, content);
      } else {
        await this.vault.create(filepath, content);
      }
      return {
        success: true,
        note,
        markdownPath: filepath
      };
    } catch (error) {
      return {
        success: false,
        note,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Update multiple notes with progress tracking
   */
  async updateNotesWithProgress(notes, localPaths, onProgress) {
    let successCount = 0;
    let failureCount = 0;
    const total = notes.length;
    for (let i = 0; i < notes.length; i++) {
      const note = notes[i];
      const localPath = localPaths.get(note.id);
      onProgress(i + 1, total, successCount, failureCount, note.name);
      if (!localPath) {
        console.warn(`No local path found for note ${note.id}, skipping update`);
        failureCount++;
        continue;
      }
      try {
        await this.updateSingleNote(note, localPath);
        successCount++;
      } catch (error) {
        console.error(`Failed to update ${note.name}:`, error);
        failureCount++;
      }
    }
    return successCount;
  }
  /**
   * Update a single note with selective update support
   */
  async updateSingleNote(note, existingPath) {
    if (this.importMode === "pdf-only") {
      return this.importPdfOnly(note);
    }
    try {
      const file = this.vault.getAbstractFileByPath(existingPath);
      if (!file) {
        throw new Error(`File not found: ${existingPath}`);
      }
      const existingContent = await this.vault.read(file);
      const existingFrontmatter = parseFrontmatter(existingContent);
      let newContent;
      let pdfVaultPath = existingFrontmatter.pdf_attachment;
      if (this.exportOptions.attachPdf && this.importMode === "markdown-with-pdf") {
        if (!pdfVaultPath || this.shouldUpdatePdf()) {
          pdfVaultPath = await this.handlePdfAttachment(note);
        }
      }
      let thumbnailBase64;
      if (this.exportOptions.includeThumbnail) {
        thumbnailBase64 = await this.client.getThumbnail(note.id) || void 0;
      }
      if (this.updateOptions) {
        newContent = this.applySelectiveUpdate(
          existingContent,
          note,
          pdfVaultPath,
          thumbnailBase64
        );
      } else {
        newContent = generateMarkdown(note, this.exportOptions, pdfVaultPath, thumbnailBase64);
      }
      await this.vault.modify(file, newContent);
      return {
        success: true,
        note,
        markdownPath: existingPath,
        pdfPath: pdfVaultPath
      };
    } catch (error) {
      return {
        success: false,
        note,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Apply selective update based on update options
   */
  applySelectiveUpdate(existingContent, note, pdfVaultPath, _thumbnailBase64) {
    if (!this.updateOptions) {
      return existingContent;
    }
    const { mode, specificFields, preserveCustomFields } = this.updateOptions;
    const newFrontmatter = {
      name: note.name,
      supernote_id: note.id,
      source: note.path,
      created: new Date(note.createdAt).toISOString().split("T")[0],
      modified: new Date(note.modifiedAt).toISOString().split("T")[0],
      pages: note.pageCount,
      size: `${Math.round(note.size / 1024)} KB`
    };
    if (pdfVaultPath) {
      newFrontmatter.pdf_attachment = pdfVaultPath;
    }
    switch (mode) {
      case "frontmatter-only":
        return updateFrontmatter(existingContent, newFrontmatter, preserveCustomFields);
      case "content-only":
        return existingContent;
      case "specific-frontmatter":
        return updateFrontmatter(existingContent, newFrontmatter, preserveCustomFields, specificFields);
      case "all":
      default:
        return generateMarkdown(
          note,
          this.updateOptions.exportOptions,
          pdfVaultPath
        );
    }
  }
  /**
   * Handle PDF attachment - download .note file and convert to PDF locally
   */
  async handlePdfAttachment(note) {
    const noteData = await this.client.downloadNoteFile(note.path);
    const conversionResult = await this.pdfConverter.convert(noteData, note.id);
    if (!conversionResult.success || !conversionResult.pdfData) {
      throw new Error(`PDF conversion failed: ${conversionResult.error || "Unknown error"}`);
    }
    const pdfFilename = generatePdfFilename(note, this.filenameTemplate);
    const pdfVaultPath = this.buildVaultPath(this.pdfFolder, note, pdfFilename);
    const folderPath = pdfVaultPath.substring(0, pdfVaultPath.lastIndexOf("/"));
    if (folderPath) {
      await this.ensureFolderExists(folderPath);
    }
    const existingPdf = this.vault.getAbstractFileByPath(pdfVaultPath);
    if (existingPdf) {
      await this.vault.modifyBinary(existingPdf, conversionResult.pdfData);
    } else {
      await this.vault.createBinary(pdfVaultPath, conversionResult.pdfData);
    }
    console.log(`Converted ${note.name} to PDF in ${conversionResult.conversionTimeMs}ms`);
    return pdfVaultPath;
  }
  /**
   * Check if PDF should be updated based on update options
   */
  shouldUpdatePdf() {
    if (!this.updateOptions)
      return true;
    return this.updateOptions.mode === "all";
  }
  /**
   * Ensure a folder exists in the vault
   */
  async ensureFolderExists(path3) {
    const normalizedPath = path3.startsWith("/") ? path3.slice(1) : path3;
    const folder = this.vault.getAbstractFileByPath(normalizedPath);
    if (!folder) {
      const parts = normalizedPath.split("/");
      let currentPath = "";
      for (const part of parts) {
        currentPath = currentPath ? `${currentPath}/${part}` : part;
        const existing = this.vault.getAbstractFileByPath(currentPath);
        if (!existing) {
          await this.vault.createFolder(currentPath);
        } else if (!(existing instanceof import_obsidian9.TFolder)) {
          throw new Error(`Path ${currentPath} exists but is not a folder`);
        }
      }
    } else if (!(folder instanceof import_obsidian9.TFolder)) {
      throw new Error(`Path ${normalizedPath} exists but is not a folder`);
    }
  }
};

// src/main.ts
var SupernoteCompanionPlugin = class extends import_obsidian10.Plugin {
  constructor() {
    super(...arguments);
    this.apiClient = null;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SupernoteSettingTab(this.app, this));
    this.registerCommands();
    console.log("Supernote Companion plugin loaded");
  }
  onunload() {
    console.log("Supernote Companion plugin unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Get or create the API client for communicating with the Supernote device
   */
  getAPIClient() {
    if (!this.apiClient) {
      if (!this.settings.deviceIp) {
        const useMock = window.SUPERNOTE_DEBUG || false;
        if (useMock) {
          this.apiClient = new MockSupernoteAPIClient();
        } else {
          throw new Error("Supernote device IP not configured. Please set it in the plugin settings.");
        }
      } else {
        this.apiClient = new SupernoteAPIClient(
          this.settings.deviceIp,
          this.settings.devicePort,
          this.settings.connectionTimeout
        );
      }
    }
    return this.apiClient;
  }
  /**
   * Reset API client (call after settings change)
   */
  resetAPIClient() {
    this.apiClient = null;
  }
  /**
   * Create a NoteImporter with current settings
   */
  createImporter(exportOptions) {
    const client = this.getAPIClient();
    return new NoteImporter(
      this.app.vault,
      client,
      this.settings.notesFolder,
      this.settings.pdfFolder,
      this.settings.importMode,
      this.settings.filenameTemplate,
      this.settings.preserveFolderStructure,
      exportOptions || this.getExportOptions(),
      this.settings.converterMode,
      this.settings.converterPath
    );
  }
  /**
   * Register all plugin commands
   */
  registerCommands() {
    this.addCommand({
      id: "check-sync-status",
      name: "Check sync status",
      callback: async () => await this.checkSyncStatus()
    });
    this.addCommand({
      id: "import-new-notes",
      name: "Import new notes",
      callback: async () => await this.importNewNotes()
    });
    this.addCommand({
      id: "update-existing-notes",
      name: "Update existing notes",
      callback: async () => await this.updateExistingNotes()
    });
    this.addCommand({
      id: "bulk-export-all",
      name: "Bulk export all notes",
      callback: async () => await this.bulkExportAll()
    });
    this.addCommand({
      id: "manage-trashed-notes",
      name: "Manage trashed notes",
      callback: async () => await this.manageTrash()
    });
    this.addCommand({
      id: "test-connection",
      name: "Test Supernote connection",
      callback: async () => await this.testConnection()
    });
  }
  /**
   * Test connection to Supernote device
   */
  async testConnection() {
    if (!this.settings.deviceIp) {
      new import_obsidian10.Notice("Please configure your Supernote device IP in settings first.");
      return;
    }
    new import_obsidian10.Notice("Testing connection to Supernote device...");
    try {
      const client = this.getAPIClient();
      const status = await client.checkConnection();
      if (status.connected) {
        new import_obsidian10.Notice(`Connected to Supernote at ${this.settings.deviceIp}:${this.settings.devicePort}`);
      } else {
        new import_obsidian10.Notice(`Failed to connect: ${status.error || "Unknown error"}

Make sure Browse & Access is enabled on your Supernote.`);
      }
    } catch (error) {
      new import_obsidian10.Notice(`Connection error: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Check sync status command
   */
  async checkSyncStatus() {
    if (!this.settings.deviceIp) {
      new import_obsidian10.Notice("Please configure your Supernote device IP in settings first.");
      return;
    }
    const client = this.getAPIClient();
    try {
      new import_obsidian10.Notice("Checking sync status...");
      const response = await client.fetchNoteFiles();
      let remoteNotes = deduplicateNotes(response.data);
      remoteNotes = filterNotes(remoteNotes, this.settings.trashedNoteIds);
      const localNotes = await scanLocalNotes(this.app.vault, this.settings.notesFolder);
      const existingPdfs = await scanLocalPdfsByName(this.app.vault, this.settings.notesFolder);
      const status = calculateSyncStatus(remoteNotes, localNotes, existingPdfs);
      new SyncStatusModal(this.app, status).open();
    } catch (error) {
      console.error("Error checking sync status:", error);
      new import_obsidian10.Notice(`Failed to check sync status: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Import new notes command
   */
  async importNewNotes() {
    if (!this.settings.deviceIp) {
      new import_obsidian10.Notice("Please configure your Supernote device IP in settings first.");
      return;
    }
    const client = this.getAPIClient();
    try {
      new import_obsidian10.Notice("Fetching new notes...");
      const response = await client.fetchNoteFiles();
      let remoteNotes = deduplicateNotes(response.data);
      remoteNotes = filterNotes(remoteNotes, this.settings.trashedNoteIds);
      const localNotes = await scanLocalNotes(this.app.vault, this.settings.notesFolder);
      const existingPdfs = await scanLocalPdfsByName(this.app.vault, this.settings.notesFolder);
      const newNotes = filterNewNotes(remoteNotes, localNotes, existingPdfs);
      if (newNotes.length === 0) {
        new import_obsidian10.Notice("No new notes to import");
        return;
      }
      const sortedNotes = sortNotes(newNotes, "date", true);
      new ConfirmationModal(
        this.app,
        sortedNotes,
        "import",
        async (selectedNotes) => {
          await this.executeImport(selectedNotes);
        },
        () => {
          new import_obsidian10.Notice("Import cancelled");
        },
        async (noteId) => {
          await this.trashNote(noteId);
        }
      ).open();
    } catch (error) {
      console.error("Error importing new notes:", error);
      new import_obsidian10.Notice(`Failed to fetch notes: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Execute the actual import
   */
  async executeImport(notes) {
    if (notes.length === 0) {
      new import_obsidian10.Notice("No notes selected");
      return;
    }
    const progressNotice = new import_obsidian10.Notice("Starting import...", 0);
    try {
      const importer = this.createImporter();
      let finalFailureCount = 0;
      const successCount = await importer.importNotesWithProgress(
        notes,
        (current, total, success, failures, title) => {
          finalFailureCount = failures;
          progressNotice.setMessage(
            `Importing: ${title}
Progress: ${current}/${total} - ${success} success, ${failures} failed`
          );
        }
      );
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      progressNotice.setMessage(`Successfully imported ${successCount} note(s)`);
      setTimeout(() => progressNotice.hide(), 3e3);
      if (finalFailureCount > 0) {
        new import_obsidian10.Notice(`Failed to import ${finalFailureCount} note(s)`);
      }
    } catch (error) {
      progressNotice.hide();
      console.error("Error during import:", error);
      new import_obsidian10.Notice(`Import failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Update existing notes command
   */
  async updateExistingNotes() {
    if (!this.settings.deviceIp) {
      new import_obsidian10.Notice("Please configure your Supernote device IP in settings first.");
      return;
    }
    const client = this.getAPIClient();
    try {
      new import_obsidian10.Notice("Fetching notes to update...");
      const response = await client.fetchNoteFiles();
      let remoteNotes = deduplicateNotes(response.data);
      remoteNotes = filterNotes(remoteNotes, this.settings.trashedNoteIds);
      const localNotes = await scanLocalNotes(this.app.vault, this.settings.notesFolder);
      const existingNotes = filterExistingNotes(remoteNotes, localNotes);
      if (existingNotes.length === 0) {
        new import_obsidian10.Notice("No notes to update");
        return;
      }
      const { modified, unmodified } = splitByModificationStatus(
        existingNotes,
        localNotes,
        this.settings.lastSync
      );
      let notesToShow;
      let skippedCount = 0;
      if (this.settings.updateModifiedFiles === "skip") {
        notesToShow = unmodified;
        skippedCount = modified.length;
        if (notesToShow.length === 0) {
          new import_obsidian10.Notice(`No notes to update (${skippedCount} modified file(s) skipped)`);
          return;
        }
        if (skippedCount > 0) {
          new import_obsidian10.Notice(`${skippedCount} modified file(s) will be skipped`);
        }
      } else {
        notesToShow = existingNotes;
      }
      new UpdateConfigModal(
        this.app,
        this.settings.updateMode,
        this.settings.specificFrontmatterFields,
        this.settings.tagsMergeStrategy,
        this.settings.preserveCustomFields,
        this.getExportOptions(),
        async (updateOptions) => {
          await this.showUpdatePreview(notesToShow, localNotes, updateOptions);
        },
        () => {
          new import_obsidian10.Notice("Update cancelled");
        }
      ).open();
    } catch (error) {
      console.error("Error updating notes:", error);
      new import_obsidian10.Notice(`Failed to fetch notes: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Show update preview and then confirmation
   */
  async showUpdatePreview(notes, localNotes, updateOptions) {
    const previewNotice = new import_obsidian10.Notice("Generating update preview...", 0);
    try {
      const previews = [];
      for (let i = 0; i < notes.length; i++) {
        const note = notes[i];
        const localFile = localNotes.get(note.id);
        if (!localFile)
          continue;
        previewNotice.setMessage(`Analyzing ${i + 1}/${notes.length}: ${note.name}`);
        previews.push({
          note,
          localFile,
          preview: {
            hasChanges: true,
            frontmatterChanges: [
              { field: "modified", oldValue: "", newValue: note.modifiedAt }
            ],
            contentChanged: updateOptions.mode === "all" || updateOptions.mode === "content-only",
            customFieldsPreserved: updateOptions.preserveCustomFields ? ["custom_field"] : []
          }
        });
      }
      previewNotice.hide();
      if (previews.length === 0) {
        new import_obsidian10.Notice("No changes detected");
        return;
      }
      new UpdatePreviewModal(
        this.app,
        previews,
        updateOptions,
        () => {
          const notesToUpdate = previews.map((p) => p.note);
          new ConfirmationModal(
            this.app,
            notesToUpdate,
            "update",
            async (selectedNotes) => {
              await this.executeUpdate(selectedNotes, localNotes, updateOptions);
            },
            () => {
              new import_obsidian10.Notice("Update cancelled");
            },
            async (noteId) => {
              await this.trashNote(noteId);
            },
            this.settings.updateModifiedFiles === "ask" ? this.settings.lastSync : void 0,
            this.settings.updateModifiedFiles === "ask" ? localNotes : void 0
          ).open();
        },
        () => {
          new import_obsidian10.Notice("Update cancelled");
        }
      ).open();
    } catch (error) {
      previewNotice.hide();
      console.error("Error generating preview:", error);
      new import_obsidian10.Notice(`Failed to generate preview: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Execute the actual update
   */
  async executeUpdate(notes, localNotes, updateOptions) {
    if (notes.length === 0) {
      new import_obsidian10.Notice("No notes selected");
      return;
    }
    const progressNotice = new import_obsidian10.Notice("Starting update...", 0);
    try {
      const importer = this.createImporter(updateOptions.exportOptions);
      importer.setUpdateOptions(updateOptions);
      const pathMap = /* @__PURE__ */ new Map();
      notes.forEach((note) => {
        const local = localNotes.get(note.id);
        if (local) {
          pathMap.set(note.id, local.path);
        }
      });
      let finalFailureCount = 0;
      const successCount = await importer.updateNotesWithProgress(
        notes,
        pathMap,
        (current, total, success, failures, title) => {
          finalFailureCount = failures;
          progressNotice.setMessage(
            `Updating: ${title}
Progress: ${current}/${total} - ${success} success, ${failures} failed`
          );
        }
      );
      this.settings.lastSync = Date.now();
      await this.saveSettings();
      progressNotice.setMessage(`Successfully updated ${successCount} note(s)`);
      setTimeout(() => progressNotice.hide(), 3e3);
      if (finalFailureCount > 0) {
        new import_obsidian10.Notice(`Failed to update ${finalFailureCount} note(s)`);
      }
    } catch (error) {
      progressNotice.hide();
      console.error("Error during update:", error);
      new import_obsidian10.Notice(`Update failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Bulk export all notes command
   */
  async bulkExportAll() {
    if (!this.settings.deviceIp) {
      new import_obsidian10.Notice("Please configure your Supernote device IP in settings first.");
      return;
    }
    const client = this.getAPIClient();
    try {
      new import_obsidian10.Notice("Fetching all notes...");
      const response = await client.fetchNoteFiles();
      let allNotes = deduplicateNotes(response.data);
      allNotes = filterNotes(allNotes, this.settings.trashedNoteIds);
      if (allNotes.length === 0) {
        new import_obsidian10.Notice("No notes found");
        return;
      }
      const sortedNotes = sortNotes(allNotes, "date", true);
      new ConfirmationModal(
        this.app,
        sortedNotes,
        "export",
        async (selectedNotes) => {
          await this.executeImport(selectedNotes);
        },
        () => {
          new import_obsidian10.Notice("Export cancelled");
        },
        async (noteId) => {
          await this.trashNote(noteId);
        }
      ).open();
    } catch (error) {
      console.error("Error bulk exporting:", error);
      new import_obsidian10.Notice(`Failed to fetch notes: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Manage trashed notes command
   */
  async manageTrash() {
    try {
      let trashedNotes = [];
      if (this.settings.trashedNoteIds.length > 0 && this.settings.deviceIp) {
        try {
          const client = this.getAPIClient();
          const response = await client.fetchNoteFiles();
          trashedNotes = response.data.filter(
            (n) => this.settings.trashedNoteIds.includes(n.id)
          );
        } catch (e) {
          trashedNotes = [];
        }
      }
      new TrashManagementModal(
        this.app,
        this.settings.trashedNoteIds,
        trashedNotes,
        async (noteId) => {
          await this.restoreNote(noteId);
        },
        async () => {
          await this.restoreAllNotes();
        }
      ).open();
    } catch (error) {
      console.error("Error managing trash:", error);
      new import_obsidian10.Notice(`Failed to open trash manager: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
  }
  /**
   * Add a note to trash (exclude from future syncs)
   */
  async trashNote(noteId) {
    if (!this.settings.trashedNoteIds.includes(noteId)) {
      this.settings.trashedNoteIds.push(noteId);
      await this.saveSettings();
      new import_obsidian10.Notice("Note trashed");
    }
  }
  /**
   * Restore a note from trash
   */
  async restoreNote(noteId) {
    this.settings.trashedNoteIds = this.settings.trashedNoteIds.filter((id) => id !== noteId);
    await this.saveSettings();
  }
  /**
   * Restore all notes from trash
   */
  async restoreAllNotes() {
    this.settings.trashedNoteIds = [];
    await this.saveSettings();
  }
  /**
   * Get export options from settings
   */
  getExportOptions() {
    return {
      attachPdf: this.settings.attachPdf,
      includeThumbnail: this.settings.includeThumbnail
    };
  }
};
/*! Bundled license information:

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
